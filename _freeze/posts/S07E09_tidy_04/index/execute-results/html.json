{
  "hash": "5ed694dccfb83f4aa708a572030f1382",
  "result": {
    "markdown": "---\ntitle: \"Tidy Data and Pivoting\"\nauthor: \"Aaron Max Wiedemer\"\ndate: \"2024-03-08\"\ncategories: [r-basics, tidyverse]\ntitle-block-banner: false\nnumber-depth: 3\nimage: img/tidy_data_img.jpeg\neditor_options:\n  chunk_output_type: console\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\n    class-output: styled-output\n---\n\n\n<br>\n\n![Tidy Data By Julia Lowndes and Allison Horst](img/tidy_data_img.jpeg \"Tidy Data By Julia Lowndes and Allison Horst\")\n\n# Overview\n\n::: {.callout-tip title=\"Document Summary\" collapse=\"false\"}\n\n**tidy data** : a way of organizing data where *columns contain variables* and *rows contain observations*\n\n**Terms**\n\n- **variable** : contains values of an attribute that is measured (i.e., length, sex, pH, color)\n\n- **observation** : contains all the values measured on the same unit (i.e., person, sample, day)\n\n**Functions**\n\n- **pivot_longer()** : a function that \"lengthens\" data by transforming a set of columns containing values into two columns - one containing the previous column names, and the other contain all of the values. This is the inverse of `pivot_wider()`\n\n- **pivot_wider()** : a function that \"widens\" data by transforming a set of two columns (though can be more) containing names and values into a larger set of columns. This is the inverse of `pivot_longer()`\n:::\n\n## Starting note\n\nMuch of this page is inspired from and has examples from - [Hadley Wickam's Tidy Data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) - [R for Data Science](https://r4ds.had.co.nz/tidy-data.html#wider)\n\n# Introduction\n\nSo far, we've been learning a lot of functions within the `tidyverse` to manipulate datasets\n\n-   `filter()` to choose rows\n-   `select()` to choose columns\n-   `arrange()` to sort data\n-   `rename()` to change data names\n-   `mutate()` to add and change data\n-   `summarise()` to produce data summaries\n\nToday we will be learning more about the structure of datasets, specifically **tidy data** .\n\nMost of what we have been working in code club this semester has actually been using tidy data, as most functions in the **tidyverse** are used to create or manipulate tidy data.\n\nWhile we have been focusing on how to manipulate tidy data, today we will be learning two functions that can be used to manipulate and more powerfully create tidy data - `pivot_longer()` and `pivot_wider()`\n\n## Set up\n\nLets get our favorite library loaded up\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"tidyverse\") # delete first hash and run to install if you havent already\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n# Tidy data\n\n## Data Structure\n\nMost datasets we work with in R are organized in a roughly rectangular grid-like format made up of **rows** and **columns** that contain some values.\n\nEach value in a dataset belongs to some **variable** and some **observation**.\n\n- A __variable__ contains values of an attribute that was measured (i.e., length, sex, pH, color)\n- An __observation__ contains all the values measured on the same thing (unit) (i.e., person, sample, day)\n\nExamples:\n\n> If I'm measuring the height of a population each person will be one **observation** and the variable I am measuring is **height**\n\n> ::: {.cell}\n> \n> ```{.r .cell-code}\n> height <- tibble(\n>  height_in = c(rnorm(43, m=67, sd=8))\n>  )\n> \n> height\n> ```\n> \n> ::: {.cell-output .cell-output-stdout}\n> ```{.styled-output}\n> # A tibble: 43 × 1\n>    height_in\n>        <dbl>\n>  1      70.3\n>  2      63.3\n>  3      74.3\n>  4      69.5\n>  5      64.6\n>  6      54.4\n>  7      77.2\n>  8      77.9\n>  9      64.4\n> 10      70.1\n> # ℹ 33 more rows\n> ```\n> :::\n> :::\n\n>\n> If I'm counting the number of geese I see on campus throughout the year every day, the variables will be **number of geese I see, and the day I count them on**. The observation will be **one instance of me counting geese on a specific day**\n>\n\n> ::: {.cell}\n> \n> ```{.r .cell-code}\n> geese <- tibble(\n>  day = seq(1:365),\n>  geese_number = c(trunc(rnorm(365, m=24, sd=10)))\n>  )\n> \n> geese\n> ```\n> \n> ::: {.cell-output .cell-output-stdout}\n> ```{.styled-output}\n> # A tibble: 365 × 2\n>      day geese_number\n>    <int>        <dbl>\n>  1     1           14\n>  2     2           24\n>  3     3           24\n>  4     4          -11\n>  5     5            6\n>  6     6           45\n>  7     7           18\n>  8     8           32\n>  9     9           10\n> 10    10           28\n> # ℹ 355 more rows\n> ```\n> :::\n> :::\n\nThis may sound like review, but in practice can be somewhat tricky\n\n::: {.callout-warning .callout-warning icon=\"flase\" }\n## Question \n\nLooking at the `diamonds` dataset, what is the observation and variable of the the value `diamonds[5,7]` ?\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds[5,7]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 1 × 1\n  price\n  <int>\n1   335\n```\n:::\n:::\n\n\nThe observation here is the **5th diamond** and the variable we are measuring is **price**\n\n</details>\n\n:::\n\n## Pre-Tidy Date\n\n> \"All tidy data sets are alike. Each messy dataset is messy in its own way\" - Hadley Wickham.\n\nAt risk of stating the obvious, organizing values in datasets can be accomplished in many ways\n\nHere with an example of table of student grades on several assignments adapted from [Hadley Wickam's Tidy Data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassroom <- tribble(\n  ~name,    ~quiz1, ~quiz2, ~test1,\n  \"Billy\",  NA,     \"67\",    \"75\",\n  \"Suzy\",   \"44\",    NA,     NA,\n  \"Lionel\", \"86\",    \"74\",    \"84\",\n  \"Jenny\",  \"94\",    \"98\",    \"88\"\n  )\n\nclassroom\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 4 × 4\n  name   quiz1 quiz2 test1\n  <chr>  <chr> <chr> <chr>\n1 Billy  <NA>  67    75   \n2 Suzy   44    <NA>  <NA> \n3 Lionel 86    74    84   \n4 Jenny  94    98    88   \n```\n:::\n:::\n\n\nThere is more than one way to organize this information in a table - for instance here we can flip (transpose) the table to have student names in columns and assessments in rows\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n  ~assessment, ~Billy, ~Suzy, ~Lionel, ~Jenny,\n  \"quiz1\",     NA,     \"44\",   \"86\",     \"94\",\n  \"quiz2\",     \"67\",    NA,    \"74\",     \"98\",\n  \"test1\",     \"75\",    NA,    \"84\",     \"88\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 3 × 5\n  assessment Billy Suzy  Lionel Jenny\n  <chr>      <chr> <chr> <chr>  <chr>\n1 quiz1      <NA>  44    86     94   \n2 quiz2      67    <NA>  74     98   \n3 test1      75    <NA>  84     88   \n```\n:::\n:::\n\n\nThis data isn't **tidy data** yet though.\n\n::: {.callout-note title=\"SIde Note: Different Organizations Serve Different Purposes\" collapse=\"false\"}\nDifferent ways of organizing data can serve different purposes - some ways of organizing data are great for collecting data, some good for analyzing data, some both, and some neither.\n:::\n\n### The look of tidy data\n\nRoughly speaking, in tidy data **columns contain variables** and **rows contain observations**\n\nHere's the dataset manually remade in a tidy format\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_classroom <- tibble( name = c( rep( \"Billy\", 3), rep( \"Jenny\", 3), rep(\"Lionel\", 3), rep(\"Suzy\", 3)),\n        assessment = c( rep(c(\"quiz1\", \"quiz2\", \"test1\"), 4)),\n        grade = c(NA, \"67\", \"75\", \"94\", \"98\", \"88\", \"86\", \"74\", \"84\", \"44\", NA, NA))\n\n\ntidy_classroom\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 12 × 3\n   name   assessment grade\n   <chr>  <chr>      <chr>\n 1 Billy  quiz1      <NA> \n 2 Billy  quiz2      67   \n 3 Billy  test1      75   \n 4 Jenny  quiz1      94   \n 5 Jenny  quiz2      98   \n 6 Jenny  test1      88   \n 7 Lionel quiz1      86   \n 8 Lionel quiz2      74   \n 9 Lionel test1      84   \n10 Suzy   quiz1      44   \n11 Suzy   quiz2      <NA> \n12 Suzy   test1      <NA> \n```\n:::\n:::\n\n\nHere, the values, variables, and observations are more clear\n\nThe variables are\n\n1.  the __names__ of the students (in the `name` column)\n2.  the __assessments__ (in the `assessment` column)\n3.  the __grades__ (in the `grade` column)\n\nEach observation here is __a particular grade, on each assessmnet, for each student__.\n\n::: {.callout-note title=\"Note\" collapse=\"false\"}\nLook at the __dimensions__ of this table. From this, we can immediatly tell the number of variables, and the number of observations in this dataset\n:::\n\n## Tidy data definition\n\nTidy data is a standard way of organizing data, and is defined by 3 things\n\n__In tidy data__\n\n1.  __Each variable is one column__; columns are single variables\n2.  __Each observation is one row__; rows are single observations\n3.  __Each value is a cell__; cells are values\n\n**Messy data** is defined as any data organization that is not tidy data\n\n\n#### Why use tidy data?\n\n- Having data structured as tidy data makes it easier to manipulate and analyze data in __tidy R__ - in fact, *most of the functions we have been learning up to now have been preformed on tidy data* - this is the **tidyverse** after all\n\n- Some functions require tidy data, and most operations on data in the __tidyverse__ are made significantly easier by having your data as tidy data (i.e., data visualization, statistics)\n\n- Having data in a standardized format makes it easier to collaborate on\n\n::: {.callout-note title=\"Order of Columns\" collapse=\"false\"}\n_A note on ordering of columns_ : While order of columns doesn't really matter for data to be considered tidy, it is standard and common practice to put meta data (aka fixed or random variables) first, followed by the columns for measured data (i.e., sample name columns go first)\n:::\n\n# Making data tidy - `pivot_longer()` and `pivot_wider()`\n\nNot all data is tidy, which creates the need for us to know how to clean it.\n\n## Pivoting Longer\n\nOne common problem mentioned in R for data science and by Hadley Wickham is when you __have column names that are actually variable values__ (when a single variable is spread across multiple columns)\n\n::: {.callout-note title=\"Sidenote\" collapse=\"false\"}\nHaving a set of columns with variable values for names is actually very common in metabomolics or genomics data, where column titles are metabolites, genes, taxa, etc.\n:::\n\nHere is a dataset with this issue - This data denotes the population of Afghanistan, Brazil, and China for the years 1999 and 2000\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4b\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 3 × 3\n  country         `1999`     `2000`\n  <chr>            <dbl>      <dbl>\n1 Afghanistan   19987071   20595360\n2 Brazil       172006362  174504898\n3 China       1272915272 1280428583\n```\n:::\n:::\n\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question\n\nWhat are the variables in the `table4b` data?\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\nThe variables are\n\n- __country__\n- __year__\n- __population__\n\n</details>\n\n:::\n\nThis format of data is sometimes called **wide** data, where the row of column names (the very first row) actually contains variable values.\n\nIn this data it doesn't look very wide, but imagine how much wider if data was taken every year up to or past this year. Wide data tends to get wide very quickly.\n\n> For an example of very wide data, look at the `who` dataset\n>\n> ::: {.cell}\n> \n> ```{.r .cell-code}\n> data(who)\n>  who\n> ```\n> \n> ::: {.cell-output .cell-output-stdout}\n> ```{.styled-output}\n> # A tibble: 7,240 × 60\n>    country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n>    <chr>    <chr> <chr> <dbl>       <dbl>        <dbl>        <dbl>        <dbl>\n>  1 Afghani… AF    AFG    1980          NA           NA           NA           NA\n>  2 Afghani… AF    AFG    1981          NA           NA           NA           NA\n>  3 Afghani… AF    AFG    1982          NA           NA           NA           NA\n>  4 Afghani… AF    AFG    1983          NA           NA           NA           NA\n>  5 Afghani… AF    AFG    1984          NA           NA           NA           NA\n>  6 Afghani… AF    AFG    1985          NA           NA           NA           NA\n>  7 Afghani… AF    AFG    1986          NA           NA           NA           NA\n>  8 Afghani… AF    AFG    1987          NA           NA           NA           NA\n>  9 Afghani… AF    AFG    1988          NA           NA           NA           NA\n> 10 Afghani… AF    AFG    1989          NA           NA           NA           NA\n> # ℹ 7,230 more rows\n> # ℹ 52 more variables: new_sp_m4554 <dbl>, new_sp_m5564 <dbl>,\n> #   new_sp_m65 <dbl>, new_sp_f014 <dbl>, new_sp_f1524 <dbl>,\n> #   new_sp_f2534 <dbl>, new_sp_f3544 <dbl>, new_sp_f4554 <dbl>,\n> #   new_sp_f5564 <dbl>, new_sp_f65 <dbl>, new_sn_m014 <dbl>,\n> #   new_sn_m1524 <dbl>, new_sn_m2534 <dbl>, new_sn_m3544 <dbl>,\n> #   new_sn_m4554 <dbl>, new_sn_m5564 <dbl>, new_sn_m65 <dbl>, …\n> ```\n> :::\n> :::\n\nTo make this data tidy, we need to the the column names (the year variable) and turn it into its own column (called `year`), and take all of the population data and put that into a second variable column (called `population`)\n\nPreviously with the `classroom` data we did this manually, but there is a much better way to pivot from wide messy data, to longer tidy data with the function `pivot_longer`\n\nLets look at the help file for it\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?pivot_longer\n```\n:::\n\n\nFrom this, we see that the `pivot_longer` function can take a lot of aruguments, but there are only a few important ones\n\n1.  `cols`, in which we select the columns to pivot (i.e., the columns whos names contain a variable)\n2.  `names_to`, in which we create a new column for where our old column names are to be put into\n3.  `values_to`, in which we create a second new column for the values to be put into\n\nHere's what that looks like in our example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_table4b <- table4b |> \n  pivot_longer(cols = `1999`:`2000`, \n               names_to = \"year\", \n               values_to = \"population\") \n\n# note here the numbers are in backticks. This is because R treats column names as characters, and calling a name as number data won't work here. \n\n# the new column names also need to be in quotes here\n\ntidy_table4b\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 6 × 3\n  country     year  population\n  <chr>       <chr>      <dbl>\n1 Afghanistan 1999    19987071\n2 Afghanistan 2000    20595360\n3 Brazil      1999   172006362\n4 Brazil      2000   174504898\n5 China       1999  1272915272\n6 China       2000  1280428583\n```\n:::\n:::\n\n\nusing `pivot_longer` we turned a 3x3 table where the column names stored variable values into a 6x3 table where each column contains a single variable, and each row a single observation - and presto, tidy data!\n\nOne other thing to note here is that we are not pivoting every column. In some datasets you may only have a few columns that you would like to be longer\n\n### More examples and uses of pivot\n\nPivoting isn't just for cleaning up! When combined with other functions, pivoting can also be a very useful way to manipulate data to make it easier to analyze\n\nLast week, we used the summary function to find the mean height, width and depth of diamonds in the `diamonds` dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(diamonds)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  summarise(mean_x = mean(x),\n            mean_y = mean(y),\n            mean_z = mean(z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 1 × 3\n  mean_x mean_y mean_z\n   <dbl>  <dbl>  <dbl>\n1   5.73   5.73   3.54\n```\n:::\n:::\n\n\nFor this we had to create a new column for every dimensional mean, which a.) takes a while to type, especially if we wanted to find the mean of further values and b.) comes out to not be tidy data\n\nAnother way to find the means for these columns is to use the `pivot_longer` function to make another column which we can group the values by\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \npivot_longer(cols = c(x:z), \n             names_to = \"dimension\", \n             values_to = \"value\") |> \n  summarise(mean_value = mean(value),\n            .by = dimension)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 3 × 2\n  dimension mean_value\n  <chr>          <dbl>\n1 x               5.73\n2 y               5.73\n3 z               3.54\n```\n:::\n\n```{.r .cell-code}\n# note in cols, I'm not specifying x, y, and z individually. In the dataset they are all next to each other, so I can use the : operator to signify that I want columns x through z. This can be really helpful on wider datasets. \n```\n:::\n\n\nHere we only have three values, but for wider datasets this can be a very powerful tool\n\n### Pivot longer problems\n\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question 1\n\nMake the classroom data from earlier into a tidy format using `pivot_longer`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassroom <- tribble(\n  ~name,    ~quiz1, ~quiz2, ~test1,\n  \"Billy\",  NA,     \"D\",    \"C\",\n  \"Suzy\",   \"F\",    NA,     NA,\n  \"Lionel\", \"B\",    \"C\",    \"B\",\n  \"Jenny\",  \"A\",    \"A\",    \"B\"\n  )\n```\n:::\n\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassroom |> \n  pivot_longer(cols = c(quiz1,quiz2, test1), \n               names_to = \"assesment\", \n               values_to = \"grade\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 12 × 3\n   name   assesment grade\n   <chr>  <chr>     <chr>\n 1 Billy  quiz1     <NA> \n 2 Billy  quiz2     D    \n 3 Billy  test1     C    \n 4 Suzy   quiz1     F    \n 5 Suzy   quiz2     <NA> \n 6 Suzy   test1     <NA> \n 7 Lionel quiz1     B    \n 8 Lionel quiz2     C    \n 9 Lionel test1     B    \n10 Jenny  quiz1     A    \n11 Jenny  quiz2     A    \n12 Jenny  test1     B    \n```\n:::\n:::\n\n\n</details>\n\n:::\n\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question 2\n\nFind the means, minimum values, maximum values, and standard deviations of all of the numeric columns in the `diamonds` dataset using `pivot_longer` followed by `summarise`\n\n<details>\n\n<summary><b>Hint</b> (click here)</summary>\n\nWhich are the numeric columns?\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\ntibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n```\n:::\n:::\n\n\n</details>\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  pivot_longer(cols = c(carat,depth:z), \n               names_to = \"parameter\", \n               values_to = \"value\") |> \n  summarise(mean = mean(value),\n            min = min(value),\n            max = max(value),\n            sd = sd(value),\n            .by = parameter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 7 × 5\n  parameter     mean   min      max       sd\n  <chr>        <dbl> <dbl>    <dbl>    <dbl>\n1 carat        0.798   0.2     5.01    0.474\n2 depth       61.7    43      79       1.43 \n3 table       57.5    43      95       2.23 \n4 price     3933.    326   18823    3989.   \n5 x            5.73    0      10.7     1.12 \n6 y            5.73    0      58.9     1.14 \n7 z            3.54    0      31.8     0.706\n```\n:::\n:::\n\n\n</details>\n\n:::\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question 3 - Challange\n\nTake a look at the very wide dataset `who`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(who)\n\nhead(who)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 6 × 60\n  country   iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n  <chr>     <chr> <chr> <dbl>       <dbl>        <dbl>        <dbl>        <dbl>\n1 Afghanis… AF    AFG    1980          NA           NA           NA           NA\n2 Afghanis… AF    AFG    1981          NA           NA           NA           NA\n3 Afghanis… AF    AFG    1982          NA           NA           NA           NA\n4 Afghanis… AF    AFG    1983          NA           NA           NA           NA\n5 Afghanis… AF    AFG    1984          NA           NA           NA           NA\n6 Afghanis… AF    AFG    1985          NA           NA           NA           NA\n# ℹ 52 more variables: new_sp_m4554 <dbl>, new_sp_m5564 <dbl>,\n#   new_sp_m65 <dbl>, new_sp_f014 <dbl>, new_sp_f1524 <dbl>,\n#   new_sp_f2534 <dbl>, new_sp_f3544 <dbl>, new_sp_f4554 <dbl>,\n#   new_sp_f5564 <dbl>, new_sp_f65 <dbl>, new_sn_m014 <dbl>,\n#   new_sn_m1524 <dbl>, new_sn_m2534 <dbl>, new_sn_m3544 <dbl>,\n#   new_sn_m4554 <dbl>, new_sn_m5564 <dbl>, new_sn_m65 <dbl>,\n#   new_sn_f014 <dbl>, new_sn_f1524 <dbl>, new_sn_f2534 <dbl>, …\n```\n:::\n:::\n\n\nThis data contains records of the counts of confirmed tuberculosis cases by country, year, and demographic group. The demographic groups are broken down by sex (m, f) and age (0-14, 15-25, 25-34, 35-44, 45-54, 55-64, unknown).\n\nAfter using `pivot_longer`, find the country with the most cases of tb in 2011.\n\n__Note__: The first four columns (`country`, `iso2`, `iso3`, and `year`) are already properly formatted and do not need to be pivoted here.\n\n<details>\n\n<summary><b>Hint</b> (click here)</summary>\n\n`NA` values are liekly to mess up your analysis here - check the `pivot_longer()` help file to see what arguments are available to remove `NA` values\n\n</details>\n\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho |> \n  pivot_longer(cols = !c(country:year), \n               names_to = \"demographic\", \n               values_to = \"tb_counts\", \n               values_drop_na = TRUE) |> \n  summarise(count = sum(tb_counts),\n            .by = c(country,year)) |> \n  filter(year=='2011') |> \n  arrange(desc(count))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 210 × 3\n   country                                year  count\n   <chr>                                 <dbl>  <dbl>\n 1 China                                  2011 865059\n 2 India                                  2011 642311\n 3 Indonesia                              2011 313601\n 4 South Africa                           2011 289111\n 5 Bangladesh                             2011 148198\n 6 Pakistan                               2011 127571\n 7 Russian Federation                     2011 104320\n 8 Philippines                            2011  93580\n 9 Democratic People's Republic of Korea  2011  85564\n10 Kenya                                  2011  84548\n# ℹ 200 more rows\n```\n:::\n:::\n\nChina is our winner with a sum of 865059 cases in 2011\n\n</details>\n\n:::\n\n\n\n## Pivoting Wider\n\nThe other function of the day here is `pivot_wider`\n\n`pivot_wider` , as the name might imply, is the inverse of `pivot_longer` and creates columns from from values stored in another column\n\n### Uses of `pivot_wider()`\n\nYou may be thinking, \"why would I ever need this? I thought the whole point was to avoid having columns of variable values\"\n\n`pivot_wider` is an especially useful function in many situations. Here are only a few:\n\n1.  `pivot_wider` is useful where we have the opposite problem as we saw when learning `pivot_longer` - when a multiple variables are stored in a single column (single observation is scattered across more than one row)\n2.  `pivot_wider` can be useful when we want to make calculations across columns\n3.  Not every function in R accepts tidy data, sometimes we do need wide data! (e.g., anything that requires a matrix, PCA)\n\n### Using `pivot_wider()`\n\nLets see how `pivot_wider()` is used\n\nThis is a dataset containing population data and the number of cases of some disease in Afghanistan, Brazil, and China for the years 1999 and 2000\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\nHere, we have columns containing **more** than one variable this time (`type` has both cases and population).\n\nLets check out `pivot_wider` to see how we can undo this and make our data tidy again\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?pivot_wider\n```\n:::\n\n\nAgain, `pivot_wider` has a bunch of arguments, but this time there are really only two essential ones\n\n1.  `names_from` which denotes the column in which our new column names are stored\n2.  `values_from` which denotes the column in which the values we will be filling our new columns with are stored\n\n::: {.callout-note title=\"Note:\" collapse=\"false\"}\nThere are fewer important arguments in `pivot_wider` - which one is missing its inverse from `pivot_longer`?\n:::\n\nLets see it in action\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2 |> \n  pivot_wider(names_from = type, values_from = count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\nWe have now seperated our variables into seperate columns, and now our rows each contain only one observation. Tidy data!\n\n### Pivot Wider Problems\n\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question 1\n\nUndo the `tidy_classroom` and make it look like one of its untidy form using `pivot_wider`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_classroom <- tibble( name = c( rep( \"Billy\", 3), rep( \"Jenny\", 3), rep(\"Lionel\", 3), rep(\"Suzy\", 3)),\n        assessment = c( rep(c(\"quiz1\", \"quiz2\", \"test1\"), 4)),\n        grade = c(NA, \"67\", \"75\", \"94\", \"98\", \"88\", \"86\", \"74\", \"84\", \"44\", NA, NA))\n```\n:::\n\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_classroom |> \n  pivot_wider(names_from = assessment, values_from = grade)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 4 × 4\n  name   quiz1 quiz2 test1\n  <chr>  <chr> <chr> <chr>\n1 Billy  <NA>  67    75   \n2 Jenny  94    98    88   \n3 Lionel 86    74    84   \n4 Suzy   44    <NA>  <NA> \n```\n:::\n:::\n\n\n</details>\n\n:::\n\n::: {.callout-warning icon=\"flase\" }\n\n## Question 2\n\nIn one of the questions from using pivot_longer, we put all of the numeric variables into two columns, here named `parameter` and `value`. Can you return the data `tampered_diamonds` to its original state?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntampered_diamonds <- diamonds |> \n  pivot_longer(cols = c(carat, depth:z), names_to = \"parameter\", values_to = \"value\")\n```\n:::\n\n\n__note__ : if you encounter an error, be sure to check the hint\n\n<details>\n\n<summary><b>Hint</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntampered_diamonds |> \n  pivot_wider(names_from = parameter, values_from = value)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Values from `value` are not uniquely identified; output will contain list-cols.\n• Use `values_fn = list` to suppress this warning.\n• Use `values_fn = {summary_fun}` to summarise duplicates.\n• Use the following dplyr code to identify duplicates.\n  {data} %>%\n  dplyr::group_by(cut, color, clarity, parameter) %>%\n  dplyr::summarise(n = dplyr::n(), .groups = \"drop\") %>%\n  dplyr::filter(n > 1L)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 276 × 10\n   cut       color clarity carat       depth       table price x     y     z    \n   <ord>     <ord> <ord>   <list>      <list>      <lis> <lis> <lis> <lis> <lis>\n 1 Ideal     E     SI2     <dbl [469]> <dbl [469]> <dbl> <dbl> <dbl> <dbl> <dbl>\n 2 Premium   E     SI1     <dbl [614]> <dbl [614]> <dbl> <dbl> <dbl> <dbl> <dbl>\n 3 Good      E     VS1     <dbl [89]>  <dbl [89]>  <dbl> <dbl> <dbl> <dbl> <dbl>\n 4 Premium   I     VS2     <dbl [315]> <dbl [315]> <dbl> <dbl> <dbl> <dbl> <dbl>\n 5 Good      J     SI2     <dbl [53]>  <dbl [53]>  <dbl> <dbl> <dbl> <dbl> <dbl>\n 6 Very Good J     VVS2    <dbl [29]>  <dbl [29]>  <dbl> <dbl> <dbl> <dbl> <dbl>\n 7 Very Good I     VVS1    <dbl [69]>  <dbl [69]>  <dbl> <dbl> <dbl> <dbl> <dbl>\n 8 Very Good H     SI1     <dbl [547]> <dbl [547]> <dbl> <dbl> <dbl> <dbl> <dbl>\n 9 Fair      E     VS2     <dbl [42]>  <dbl [42]>  <dbl> <dbl> <dbl> <dbl> <dbl>\n10 Very Good H     VS1     <dbl [257]> <dbl [257]> <dbl> <dbl> <dbl> <dbl> <dbl>\n# ℹ 266 more rows\n```\n:::\n:::\n\n\nUh-oh! Uh-oh! With what we have learned so far, we cant undo `pivot_longer` with `pivot_wider` here! Can you figure out why?\n\n</details>\n\n<details>\n\n<summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code from the error read out\ntampered_diamonds %>%\n  dplyr::group_by(cut, color, clarity, parameter) %>%\n  dplyr::summarise(n = dplyr::n(), .groups = \"drop\")  %>%\n  dplyr::filter(n > 1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 1,897 × 5\n   cut   color clarity parameter     n\n   <ord> <ord> <ord>   <chr>     <int>\n 1 Fair  D     I1      carat         4\n 2 Fair  D     I1      depth         4\n 3 Fair  D     I1      price         4\n 4 Fair  D     I1      table         4\n 5 Fair  D     I1      x             4\n 6 Fair  D     I1      y             4\n 7 Fair  D     I1      z             4\n 8 Fair  D     SI2     carat        56\n 9 Fair  D     SI2     depth        56\n10 Fair  D     SI2     price        56\n# ℹ 1,887 more rows\n```\n:::\n\n```{.r .cell-code}\n# example of multiple replicates\ntampered_diamonds |> \n  filter(cut==\"Premium\", color == \"D\", clarity==\"VS2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.styled-output}\n# A tibble: 2,373 × 5\n   cut     color clarity parameter  value\n   <ord>   <ord> <ord>   <chr>      <dbl>\n 1 Premium D     VS2     carat       0.22\n 2 Premium D     VS2     depth      59.3 \n 3 Premium D     VS2     table      62   \n 4 Premium D     VS2     price     404   \n 5 Premium D     VS2     x           3.91\n 6 Premium D     VS2     y           3.88\n 7 Premium D     VS2     z           2.31\n 8 Premium D     VS2     carat       0.71\n 9 Premium D     VS2     depth      62.5 \n10 Premium D     VS2     table      60   \n# ℹ 2,363 more rows\n```\n:::\n:::\n\n\nmultiple values for each \"type\" of diamond - not uniquely identifiable, thus we can't get to the original dataset\n\n</details>\n\n:::\n\n# Citations\n\n[Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst](https://allisonhorst.com/other-r-fun)\n\nhttps://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html\n\nhttps://r4ds.had.co.nz/tidy-data.html#wider",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}