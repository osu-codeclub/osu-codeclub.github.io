{
  "hash": "4cc2a5548d1eff112f5883dc743a48ab",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iterating part III: _purrr_'s `map()` function\"\nsubtitle: \"A deeper dive into iterating with _purrr's_ `map()` function.\"\npagetitle: \"Iteration III\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2025-04-01\"\ncategories: [functional programming, purrr]\ntitle-block-banner: false\nnumber-depth: 2\nexecute: \n  eval: true\n  cache: false\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Intro and getting started\n\nIn the last two weeks,\nyou've learned about a couple of effective coding strategies for situations where\nyou need to **repeat an operation**,\nfor example across different subsets of your data.\n**Instead of copy-pasting your code and making small edits for every copy,**\nyou can use `for` loops and functions like `map()`.\n\nToday, we will start with a recap of these approaches and then dive deeper into\nthe `map()` function (and the very similar `map_vec()`).\n\nThe `map()` function is part of the _purrr_ package,\none of the core tidyverse packages that can be loaded with `library(tidyverse)`.\nWe will also load the familiar _palmerpenguins_ dataset for a couple of examples.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n## Iteration recap\n\nWhen we iterate,\nwe repeat a procedure for each value/element in a certain collection.\n\nLet's say we have three sets of measurements (each stored in a vector):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- c(3, 74, 18)\nvec2 <- c(33, 14, 25)\nvec3 <- c(10, 88, 47)\n```\n:::\n\n\n\nWe want to compute the mean value for each of these.\nThe simplest approach would be to just repeat the code to do so three times,\nchanging only the identity of the vector that we operate on: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(vec1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(vec3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nBut we'd like to be able to avoid such code repetition.\nFirst, we may run into situations where we have many more than three collections.\nSecond, the code that we need repeat may be much longer than just a call to `mean()`. \nAll in all, the copy-and-paste routine can get very tedious, is error-prone,\nand would also make it more difficult to edit the repeated code.\n\nIn the previous two sessions, Jess has shown us two different ways of avoiding\ncode repetition.\nThe first is the `for` loop,\nwhich is a very widely used technique in programming,\nthough is not nearly as common in R as in many other languages.\nWe can iterate over our vectors with a `for` loop as follows ---\nnote that I am putting them together in a `list` to do so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (vec in list(vec1, vec2, vec3)) {\n  print(mean(vec))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667\n[1] 24\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nA more compact and elegant way of iterating is using _functional programming_,\nwhere a **function does the iteration** --- here, the `map()` function:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(.x = list(vec1, vec2, vec3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 31.66667\n\n[[2]]\n[1] 24\n\n[[3]]\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nSome notes on the syntax of the `map()` function:\n\n- The first argument (`.x`) is the collection you want to iterate over,\n  which can be a vector, list, or dataframe.\n- The second argument (`.f`) is the function that you want to apply to each\n  element of the collection.\n- The name of that function is written without parentheses:\n  `mean` and not `mean()`!\n\nUnder the hood, the function `mean()` will be run three times,\neach time with one of the vectors as its argument.\n\n<br>\n\n## Beyond the basics of `map()`\n\n### Returning vectors\n\nBy default, `map()` will return a list.\nBut in some cases, like here, we may prefer to get a vector instead.\nWe can do this with a slight variant on `map()`, `map_vec()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### How to handle additional arguments?\n\nWhat if we need to pass additional arguments to the function that `map()`\ncalls for us?\n\nFor example, let's say we had an `NA` in our data,\nwhich means that by default, `mean()` will return `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change the second element of vec1 to 2\nvec1[2] <- NA\nvec1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3 NA 18\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(vec1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]       NA 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nWe can avoid this by using `na.rm = TRUE` in a stand-alone call to `mean()`...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(vec1, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5\n```\n\n\n:::\n:::\n\n\n\n...but how can we do that with the `map()` function?\nThe below doesn't work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = mean(na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mean.default(na.rm = TRUE): argument \"x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nInstead,\nwe need to pass any additional arguments **separately**,\nbasically as if they were arguments of `map()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Defining an anonymous function within `map()`\n\nIt _is_ possible to write the function call within `map()` using parentheses ---\nbut this would essentially entail defining a function on the fly,\nwhich you can do as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = function(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\nIn practice,\nthe above syntax is most commonly used in slighly more complex situations.\nFor example, you may want to **count the number of `NA`s** in the following way,\nwhere the `is.na()` function is nested within the `sum()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(vec1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nThis poses a challenge to the standard `map()` syntax,\nbut can be easily achieved with the anonymous function syntax shown above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = function(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0 0\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n::: exercise\n\n### {{< fa user-edit >}} Exercise 1\n\n**A)** Once again compute the mean of the three sets of measurements with `map()`,\nbut now also pass the argument `trim = 0.1` to the `mean()` function\n(If you're interested,\ntype `?mean` for some information about what this argument does.)\n\n<details><summary>Click here for the solution</summary>\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nArguments are added as if they were arguments of `map()` / `map_vec()`,\nso you simply add `trim = 0.1` after a comma and don't use additional\nparentheses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = mean, na.rm = TRUE, trim = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\nWhich runs the following under the hood:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(vec1, na.rm = TRUE, trim = 0.1)\nmean(vec2, na.rm = TRUE, trim = 0.1)\nmean(vec3, na.rm = TRUE, trim = 0.1)\n```\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** Now use `map_vec()` with the `length()` function to compute the length of\neach of our vectors.\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(vec1, vec2, vec3), .f = length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3 3\n```\n\n\n:::\n:::\n\n\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n\n### {{< fa user-edit >}} Exercise 2\n\n**A)** R does not have a built-in function to compute the standard error.\nHere is how we can do so --- by taking the standard deviation using the `sd()`\nfunction and dividing it by the square root (`sqrt()`) of the number of\nobservations (`length()`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(vec1, na.rm = TRUE) / sqrt(length(vec1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.123724\n```\n\n\n:::\n:::\n\n\n\n- Based on the above code, define your own function that computes the standard error.\n  For a refresher on defining your own functions, see\n  [this section from last week's material](/posts/S09E09_functional-programming_02/#general-syntax).\n\n- Then, use your custom function inside `map_vec()` to compute the standard error\n  for our data.\n\n<details><summary>Click here for the solution for the custom function</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x) {\n  sd(x, na.rm = TRUE) / sqrt(length((x)))\n}\n```\n:::\n\n\n\n</details>\n\n<details><summary>Click here for the full solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x) {\n  sd(x, na.rm = TRUE) / sqrt(length((x)))\n}\n\nmap_vec(.x = list(vec1, vec2, vec3), .f = se)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6.123724  5.507571 22.526528\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** Now, restructure your code to compute the standard error with an anonymous\nfunction inside `map_vec()`.\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(\n  .x = list(vec1, vec2, vec3),\n  .f = function(x) sd(x, na.rm = TRUE) / sqrt(length((x)))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6.123724  5.507571 22.526528\n```\n\n\n:::\n:::\n\n\n\n</details>\n\n:::\n\n<br>\n\n## Automatic/implicit iteration in R\n\nThe example we used above with the three sets of vectors is rather contrived.\nThis speaks to the fact that in R,\nwe don't have to explicitly iterate with `for` loops or `map()` except in more\ncomplex situations.\n\nThis is because first,\niteration is in many cases \"automagic\" in R due to vectorization,\nso we don't have to iterate over the values in vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasurements_inch <- c(3, 74, 18)\n\n# Multiply each value in the vector with 2.54 :\n2.54 * measurements_inch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   7.62 187.96  45.72\n```\n\n\n:::\n:::\n\n\n\nAlso, we usually have (or can put) our data in data frames,\nwhere vectorization across rows applies as well:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(measurements_inch) |>\n  # Multiply each value in the vector with 2.54 :\n  mutate(measurements_cm = 2.54 * measurements_inch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  measurements_inch measurements_cm\n1                 3            7.62\n2                74          187.96\n3                18           45.72\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip collapse=\"true\"}\n### Iterate across groups with `summarize()` and `.by` _(Click to expand)_\n\nSpeaking of implicit iteration in data frames,\n_dplyr_ has functionality to repeat operations across subsets of the data\nwithout having to explicitly iterate over these subsets.\nFor example,\nonce the data from the above three-vector example is in a data frame...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall <- data.frame(\n  value = c(vec1, vec2, vec3),\n  group = rep(c(\"vec1\", \"vec2\",  \"vec3\"), each = 3) \n)\n\nall\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  value group\n1     3  vec1\n2    NA  vec1\n3    18  vec1\n4    33  vec2\n5    14  vec2\n6    25  vec2\n7    10  vec3\n8    88  vec3\n9    47  vec3\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n...we can use `summarize()` with `.by` to repeat computations across our sets:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall |> summarize(mean = mean(value, na.rm = TRUE), .by = group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  group     mean\n1  vec1 10.50000\n2  vec2 24.00000\n3  vec3 48.33333\n```\n\n\n:::\n:::\n\n\n\n:::\n\nHowever,\n**operating across multiple _columns_ of a dataframe is a bit more challenging,**\nand in the final section below, we'll see how to do this with `map()`.\n\n<br>\n\n## Using `map()` to iterate across columns of a data frame\n\nA data frame is really a special case of a list,\none in which each vector is of the same length and constitutes a column.\nTherefore, iterating over a dataframe with a function like `map()` means that\nyou'll repeat the operation for each column.\n\nFor example, it's easy to check what type of data each column contains by\nusing `map_vec()` with the `class()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n         \"factor\"          \"factor\"         \"numeric\"         \"numeric\" \nflipper_length_mm       body_mass_g               sex              year \n        \"integer\"         \"integer\"          \"factor\"         \"integer\" \n```\n\n\n:::\n:::\n\n\n\nSimilarly, the `n_distinct()` function computes the number of distinct (unique)\nvalues, and we can run that on each column like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = n_distinct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n                3                 3               165                81 \nflipper_length_mm       body_mass_g               sex              year \n               56                95                 3                 3 \n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip collapse=\"true\"}\n### An alternative approach: the `across()` function _(Click to expand)_\n\nYou can also operate on multiple columns using _dplyr_'s `across()` function,\nwhich should be used inside another _dplyr_ function,\nmost commonly `summarise()` or `mutate()`.\n\nFor usage in the simplest cases, like for our `map()` examples above,\nusing `across()` is more verbose than `map()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> summarise(across(.cols = everything(), .fns = n_distinct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n    <int>  <int>          <int>         <int>             <int>       <int>\n1       3      3            165            81                56          95\n# ℹ 2 more variables: sex <int>, year <int>\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nNotes on the `across()` syntax as shown above: \n\n- Its main arguments are:\n  - `.cols` -- corresponding to `.x` in `map()` (the things to operate on)\n  - `.fns` -- corresponding to `.f` in `map()` (the function to repeat)\n- You should always make an explicit column selection,\n  so for the simplest case of operating across all columns,\n  it's best to use `everything()`^[\n  The `across()` function does (still) work without `.cols()`,\n  and will then select all columns,\n  but this behavior is \"deprecated\" (outdated) and should not be used.].\n  \nOn the other hand, it is much eaier to perform group-wise computations with\n`summarise(across())` than with `map()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarise(across(.cols = everything(), .fns = n_distinct), .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>      <int>          <int>         <int>             <int>       <int>\n1 Adelie         3             79            50                33          56\n2 Gentoo         1             76            40                26          48\n3 Chinstrap      1             55            33                25          34\n# ℹ 2 more variables: sex <int>, year <int>\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nFinally,\nif you need to use additional arguments for the function that `across()` calls,\nyou should use the anonymous function notation that was explained in the first\nbox on this page:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarise(across(\n    .cols = where(is.numeric),\n    .fns = function(x) mean(x, na.rm = TRUE)\n    ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n           <dbl>         <dbl>             <dbl>       <dbl> <dbl>\n1           43.9          17.2              201.       4202. 2008.\n```\n\n\n:::\n:::\n\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Exercise 2\n\n**A)** Use `map_vec()` to compute the mean value for _each_ column in the\n`penguins` dataframe. Why are you getting warning messages and `NA`s?\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n               NA                NA          43.92193          17.15117 \nflipper_length_mm       body_mass_g               sex              year \n        200.91520        4201.75439                NA        2008.02907 \n```\n\n\n:::\n:::\n\n\n\nThe warning messages and `NA`s (despite using `na.rm = TRUE`) appear because \nnot some of the columns, like `species` and `island`,\ndon't contain numbers at all.\n\n</details>\n\n**B)** Can you modify the `penguins` dataframe before passing it to `map_vec()`\nso it only contains columns with numbers?\n\n<details><summary>Click here for a hint on the general workflow</summary>\n\nYou could save the modified dataframe and then use `map_vec()`,\nbut we'd prefer to use pipes as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(bill_length_mm) |>\n  map_vec(.f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm \n      43.92193 \n```\n\n\n:::\n:::\n\n\n\n_(The above only selects one column though,_\n_you'll still have to work on the `select()` function call!)_\n\n</details>\n\n<details><summary>Click here for a hint on column selection</summary>\n\nThe naive way to select all numeric columns would be to first figure out\nout which are numeric, and then simply list all of those inside `select()`.\n\nHowever, there is a handy helper function to select columns by type: `where()`:\nsee [this Help page](https://tidyselect.r-lib.org/reference/where.html).\nCan you figure out how to use it to select numeric columns?\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(where(is.numeric)) |>\n  map_vec(.f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n         43.92193          17.15117         200.91520        4201.75439 \n             year \n       2008.02907 \n```\n\n\n:::\n:::\n\n\n\n</details>\n\n**C)** Count the number of `NA`s in each column of the `penguins` dataframe\nwithin `map_vec()`.\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = function(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n                0                 0                 2                 2 \nflipper_length_mm       body_mass_g               sex              year \n                2                 2                11                 0 \n```\n\n\n:::\n:::\n\n\n\n</details>\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}