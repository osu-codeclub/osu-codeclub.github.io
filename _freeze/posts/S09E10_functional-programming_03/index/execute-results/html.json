{
  "hash": "4b822014f6a0b71d37507b61a19bde32",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iterating part III: `purrr:map()`\"\nsubtitle: \"A deeper dive into iterating with _purrr's_ `map()` function.\"\npagetitle: \"Iteration III\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2025-04-01\"\ncategories: [functional programming, purrr]\ntitle-block-banner: false\nnumber-depth: 2\nexecute: \n  eval: true\n  cache: false\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Intro and getting started\n\nIn the last two weeks,\nyou've learned about a couple of effective coding strategies for situations where\nyou need to repeat an operation across e.g. different subsets of data.\n**Instead of copy-pasting your code and making small edits for every copy,**\nyou can use `for` loops and functions like `map()`.\n\nToday, we will start with a recap of these approaches and then dive deeper into\nthe `map()` function (and the very similar `map_vec()`).\n\nThe `map()` function is in the _purrr_ package,\none of the core tidyverse packages that can be loaded with `library(tidyverse)`.\nWe will also load the familiar _palmerpenguins_ dataset for a couple of examples.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n## Iteration recap\n\nWhen we iterate,\nwe repeat a procedure for each value/element in a certain collection.\n\nLet's say we have three sets of measurements (each stored in a vector):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset1 <- c(3, 74, 18)\nset2 <- c(33, 14, 25)\nset3 <- c(10, 88, 47)\n```\n:::\n\n\n\nWe want to compute the mean value for each of these.\nThe simplest approach would be to just repeat the code to do so three times,\nchanging only the identity of the vector: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(set1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(set2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(set3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nBut we'd like to be able to avoid such repetition.\nFirst, we may run into situations where we have many more than three collections.\nSecond, the code that we need repeat may be much longer than just a call to `mean()`. \n\nIn the previous two sessions, Jess has shown us two different ways of avoiding\ncode repetition.\nThe first is the `for` loop,\nwhich is a very widely used technique in programming,\nthough is not nearly as common in R as in many other languages.\nWe can iterate over these sets with a `for` loop as follows ---\nnote that I am putting them together in a `list` to do so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (set in list(set1, set2, set3)) {\n  print(mean(set))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667\n[1] 24\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nA more compact and elegant way of iterating is using _functional programming_,\nwhere a **function does the iteration** --- here, the `map()` function:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(.x = list(set1, set2, set3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 31.66667\n\n[[2]]\n[1] 24\n\n[[3]]\n[1] 48.33333\n```\n\n\n:::\n:::\n\n\n\nSome notes on the syntax of the `map()` function:\n\n- The first argument (`.x`) is the collection you want to iterate over,\n  which can be a vector, list, or dataframe\n- The second argument (`.f`) is the function that you want to apply to each\n  element of the collection.\n- The name of that function is written without parentheses:\n  `mean` and not `mean()`!\n\nUnder the hood, the function `mean()` will be run three times,\neach time with one of the sets as its argument.\n\n<br>\n\n## More on `map()`\n\n### Returning vectors\n\nBy default, `map()` will return a list.\nBut in some cases, like here, we may prefer to get a vector instead.\nWe can do this with a slight variant, on `map()`, `map_vec()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.66667 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### How to handle additional arguments?\n\nWhat if we needed to pass additional arguments to the function that `map()`\ncalls for us?\n\nFor example, let's say we had an `NA` in our data,\nwhich means that by default, `mean()` will return `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change the second element of set1 to 2\nset1[2] <- NA\nset1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3 NA 18\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(set1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]       NA 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\nWe can avoid this by using `na.rm = TRUE` in a stand-alone call to `mean()`...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(set1, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5\n```\n\n\n:::\n:::\n\n\n\n...but how can we do that with the `map()` function?\nThe below doesn't work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = mean(na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mean.default(na.rm = TRUE): argument \"x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\nInstead,\nwe need to pass additional arguments separately,\n__*basically as if they were arguments of `map()`:*__\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-note collapse=\"true\"}\n\n### Defining a function on the fly within `map()` _(Click to expand)_\n\nIt _is_ possible to call the function with parentheses,\nbut this would entail essentially defining a function on the fly,\nwhich you can do as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = function(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nIn practice,\nthe above syntax is most commonly used with a\n\"truly\" **custom function that you define yourself**,\nbut one that may seem so short and context-specific that you don't\nwant to define the function separately and keep it in your environment.\n\nFor example, last week,\nwe defined our own function to compute the Coefficient of Variation (CV),\nwhich we then used in `map()` similar to the example below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv <- function(x) {\n  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)\n}\n\nmap_vec(.x = list(set1, set2, set3), .f = cv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0101525 0.3974747 0.8072501\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nBut we could instead define this function on the fly and immediately use it\nlike so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(\n  .x = list(set1, set2, set3),\n  .f = function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0101525 0.3974747 0.8072501\n```\n\n\n:::\n:::\n\n\n:::\n\n<br>\n\n::: exercise\n\n### {{< fa user-edit >}} Exercise 1\n\n**A)** Once again compute the mean of the three sets of measurements with `map()`,\nbut now also pass the argument `trim = 0.1` to the `mean()` function.\n\n<details><summary>Click here for the solution</summary>\n\nArguments are added as if they were arguments of `map()` / `map_vec()`,\nso you simply add `trim = 0.1` after a comma and don't use additional\nparentheses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = mean, na.rm = TRUE, trim = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.50000 24.00000 48.33333\n```\n\n\n:::\n:::\n\n\n\nWhich runs the following under the hood:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(set1, na.rm = TRUE, trim = 0.1)\nmean(set2, na.rm = TRUE, trim = 0.1)\nmean(set3, na.rm = TRUE, trim = 0.1)\n```\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** Now use `map_vec()` with the `length()` function to compute the length of\neach of our vectors.\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = list(set1, set2, set3), .f = length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3 3\n```\n\n\n:::\n:::\n\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**C)** R does not have a built-in function to compute the standard error.\nHere is how we can do so --- by taking the standard deviation using the `sd()`\nfunction and dividing it by the square root (`sqrt()`) of the number of\nobservations (`length()`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(set1, na.rm = TRUE) / sqrt(length(set1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.123724\n```\n\n\n:::\n:::\n\n\n\n- Based on the above code, define your own function that computes the standard error.\n  For a refresher on defining your own functions,\n  see [this section from last week's material](/posts/S09E09_functional-programming_02/#general-syntax).\n\n- Then, use your custom function inside `map_vec()` to compute the standard error\n  for our data.\n\n<details><summary>Click here for the solution for the custom function</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x) {\n  sd(x, na.rm = TRUE) / sqrt(length((x)))\n}\n```\n:::\n\n\n\n</details>\n\n<details><summary>Click here for the full solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x) {\n  sd(x, na.rm = TRUE) / sqrt(length((x)))\n}\n\nmap_vec(.x = list(set1, set2, set3), .f = se)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6.123724  5.507571 22.526528\n```\n\n\n:::\n:::\n\n\n</details>\n\n:::\n\n<br>\n\n## Automatic/implicit iteration in R\n\nThe example we used above with the three sets of vectors is rather contrived.\nThis speaks to the fact that in R,\nwe don't have to use explicit iteration like with `for` loops or `map()` except\nin more complex situations ---\nmost commonly situations where we've written a function ourself.\n\nThis is because first,\niteration is in many cases \"automagic\" due to vectorization,\nso we don't have to iterate over the values in vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasurements_inch <- c(3, 74, 18)\n\n# Multiply each value in the vector with 2.54 :\n2.54 * measurements_inch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   7.62 187.96  45.72\n```\n\n\n:::\n:::\n\n\n\nAlso, we usually have (or can put) our data in data frames,\nwhere vectorization across rows applies as well\n--- for example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(measurements_inch) |>\n  # Multiply each value in the vector with 2.54 :\n  mutate(measurements_cm = 2.54 * measurements_inch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  measurements_inch measurements_cm\n1                 3            7.62\n2                74          187.96\n3                18           45.72\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip collapse=\"false\"}\n### Iterate across groups with `summarize()` and `.by`\n\nAnd speaking of dataframes,\n_dplyr_ has functionality to repeat operations across subsets of the data\nwithout having to explicitly iterate over these subsets.\nFor example,\nonce the data from the above three-set example is in a data frame...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsets_df <- data.frame(\n  measurement = c(set1, set2, set3),\n  set = rep(c(\"set1\", \"set2\",  \"set3\"), each = 3) \n)\n\nsets_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  measurement  set\n1           3 set1\n2          NA set1\n3          18 set1\n4          33 set2\n5          14 set2\n6          25 set2\n7          10 set3\n8          88 set3\n9          47 set3\n```\n\n\n:::\n:::\n\n\n\n...then we can use `summarize()` with `.by` to repeat computations across our\nsets:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsets_df |> summarize(mean = mean(measurement, na.rm = TRUE), .by = set)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   set     mean\n1 set1 10.50000\n2 set2 24.00000\n3 set3 48.33333\n```\n\n\n:::\n:::\n\n\n\n:::\n\nHowever,\n**operating across multiple _columns_ of a dataframe is a bit more challenging,**\nand in the final section below,\nwe'll see how to do this with `map()`.\n\n<br>\n\n## Using `map()` to iterate across columns of a data frame\n\nA data frame is really a special case of a list,\none in which each vector is of the same length and constitutes a column.\nTherefore, iterating over a dataframe with a function like `map()` means that\nyou'll repeat the operation for each column.\n\nFor example, it's easy to check what type of data each column contains by\nusing `map_vec()` with the `class()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n         \"factor\"          \"factor\"         \"numeric\"         \"numeric\" \nflipper_length_mm       body_mass_g               sex              year \n        \"integer\"         \"integer\"          \"factor\"         \"integer\" \n```\n\n\n:::\n:::\n\n\n\nSimilarly, the `n_distinct()` function computes the number of distinct (unique)\nvalues, and we can run that on each column like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = n_distinct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n                3                 3               165                81 \nflipper_length_mm       body_mass_g               sex              year \n               56                95                 3                 3 \n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-note collapse=\"true\"}\n### Bonus: An alternative is the `across()` function _(Click to expand)_\n\nYou can also operate on multiple columns using _dplyr_'s `across()` function,\nwhich should be used inside another _dplyr_ function,\nmost commonly `summarise()` or `mutate()`.\n\nFor usage in the simplest cases, like for our `map()` examples above,\nusing `across()` is more verbose than `map()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> summarise(across(.cols = everything(), .fns = n_distinct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n    <int>  <int>          <int>         <int>             <int>       <int>\n1       3      3            165            81                56          95\n# ℹ 2 more variables: sex <int>, year <int>\n```\n\n\n:::\n:::\n\n\n\nNotes on `across()` syntax as shown above: \n\n- Its main arguments are:\n  - `.cols` -- corresponding to `.x` in `map()` (the things to operate on)\n  - `.fns` -- corresponding to `.f` in `map()` (the function to repeat)\n- You should always make an explicit column selection,\n  so for the simplest case of operating across all columns,\n  it's best to use `everything()`^[\n  The `across()` function does (still) work without `.cols()`,\n  and will then select all columns,\n  but this behavior is \"deprecated\" (outdated) and should not be used.].\n  \nHowever, with `summaris(across())` you can much more easily make group-wise\ncomputations than with `map()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarise(across(.cols = everything(), .fns = n_distinct), .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>      <int>          <int>         <int>             <int>       <int>\n1 Adelie         3             79            50                33          56\n2 Gentoo         1             76            40                26          48\n3 Chinstrap      1             55            33                25          34\n# ℹ 2 more variables: sex <int>, year <int>\n```\n\n\n:::\n:::\n\n\n\nFinally,\nif you need to use additional arguments for the function that `across()` calls,\nyou should use the on-the-fly function notation that was explained in the first\nbox on this page:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarise(across(\n    .cols = where(is.numeric),\n    .fns = function(x) mean(x, na.rm = TRUE)\n    ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n           <dbl>         <dbl>             <dbl>       <dbl> <dbl>\n1           43.9          17.2              201.       4202. 2008.\n```\n\n\n:::\n:::\n\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Exercise 2\n\n**A)** Use `map_vec()` to compute the mean value for _each_ column in the penguins\ndataframe. Why are you getting warning messages and `NA`s?\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = penguins, .f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n               NA                NA          43.92193          17.15117 \nflipper_length_mm       body_mass_g               sex              year \n        200.91520        4201.75439                NA        2008.02907 \n```\n\n\n:::\n:::\n\n\n\nThe warning messages and `NA`s (despite using `na.rm = TRUE`) appear because \nnot some of the columns, like `species` and `island`,\ndon't contain numbers at all.\n\n</details>\n\n**B)** Can you modify the penguins dataframe before passing it to `map_vec()`\nso it only contains columns with numbers?\n\n<details><summary>Click here for a hint on the general workflow</summary>\n\nYou could save the modified dataframe and then use `map_vec()`,\nbut we'd prefer to use pipes as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(bill_length_mm) |>\n  map_vec(.f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm \n      43.92193 \n```\n\n\n:::\n:::\n\n\n\n_(The above only selects one column though,_\n_you'll still have to work on the `select()` function call!)_\n\n</details>\n\n<details><summary>Click here for a hint on column selection</summary>\n\nThe naive way to select all numeric columns would be to first figure out\nout which are numeric, and then simply list all of those inside `select()`.\n\nHowever, there is a handy helper function to select columns by type: `where()`:\nsee [this Help page](https://tidyselect.r-lib.org/reference/where.html).\nCan you figure out how to use it to select numeric columns?\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(where(is.numeric)) |>\n  map_vec(.f = mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n         43.92193          17.15117         200.91520        4201.75439 \n             year \n       2008.02907 \n```\n\n\n:::\n:::\n\n\n\n</details>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}