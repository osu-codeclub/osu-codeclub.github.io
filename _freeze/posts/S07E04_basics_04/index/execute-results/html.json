{
  "hash": "e0e7a08011c559cf7f4d663b0a3e688a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Basics 4: Vectorized Operations and Data Frames\"\nauthor:\n  - \"Jessica Cooperstone\"\ndate: \"2024-02-02\"\ncategories: [r-basics]\ntitle-block-banner: false\nimage: img/vector-vs-df.png\n---\n\n::: {.cell}\n\n:::\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Introduction\n\nWe are going to continue our discussion about vectors that [Horacio started last week](https://osu-codeclub.github.io/posts/basics_03/#vectors-in-r) and talk about vectorized operations. It's fine if you don't know what this means, you will by the end of today's session. We are also going to introduce the idea of a data frame.\n\n## What are vectorized operations?\n\nI think its easier to see ðŸ‘€ an example of a vectorized operation, and then we can explain what is happening under the hood.\n\nLet's create a vector of high temperatures for the weather in Columbus OH in Fahrenheit from the last 7 days. I took this data from January 19 to 25, 2024.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_F <- c(26, 21, 24, 32, 33, 41, 51)\n```\n:::\n\n\nWe can call our vector to see what it contains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_F\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26 21 24 32 33 41 51\n```\n\n\n:::\n:::\n\n\nA reminder that:\n\n$$\nÂ°F = 1.8 * Â°C + 32\n$$\n\nWith some light rearrangement, we can write the code below so we can plug in a temp in Fahrenheit, and get out one in Celsius.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_C <- (temps_F - 32)/1.8\n\ntemps_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3.3333333 -6.1111111 -4.4444444  0.0000000  0.5555556  5.0000000 10.5555556\n```\n\n\n:::\n:::\n\n\nHere, we simply use the vector `temps_F` as we would any single number in a smple mathematical operation, and we convert each element or number in our our entire vector using the formula we provide. As a result, we can convert every element of our vector from Fahrenheit to Celsius.\n\n> It is worth mentioning that this is *unique in R* - many other programming languages would require a for loop or similar to do this operation, but because R is a **vectorized language**, this works easily and simply.\n\nHere is another example. Imagine you have a vector of values and you want to calculate the log base 2 value for each element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- c(20, 36, 42, 53)\n\nlog2 <- log2(raw)\n\nlog2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.321928 5.169925 5.392317 5.727920\n```\n\n\n:::\n:::\n\n\nThis is an example where we apply a formula transformation to a vector, but we can also use vectorized operations with two vectors.\n\n## Vector by vector operations\n\nLet's create some vectors. Note I am not using the `c()` function to create the vector - since I am using the `:` to indicate a string of integers from number 1 to number 2, under the hood, R automatically makes this a vector. If you were to use the `c()` function though you would get the same result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector with the values from 1 to 10, incrementing by 1\n# vector_1to10 <- c(1:10) would also work\nvector_1to10 <- 1:10\n\nvector_1to5 <- 1:5\n\nvector_1to3 <- 1:3\n\nvector_0to4 <- 0:4\n```\n:::\n\n\n::: {.callout-note title=\"What do you think will happen if we try and add `vector_1to10` and `vector_1to5`?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# a vector reminder\nvector_1to10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nvector_1to5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# adding\nvector_1to10 + vector_1to5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10  7  9 11 13 15\n```\n\n\n:::\n:::\n\n\nWe see that `vector_1to5` gets recycled, meaning once the 5 elements in the vector have been used, the addition starts back from the beginning again. If we want to be explicit:\n\n-   Element 1 of `vector_1to10` gets added to element 1 of `vector_1to5`\n-   Element 2 of `vector_1to10` gets added to element 2 of `vector_1to5`\n-   Element 3 of `vector_1to10` gets added to element 3 of `vector_1to5`\n-   Element 4 of `vector_1to10` gets added to element 4 of `vector_1to5`\n-   Element 5 of `vector_1to10` gets added to element 5 of `vector_1to5`.\n-   Element 6 of `vector_1to10` gets added to **element 1** of `vector_1to5`\n\nand so on...\n\nâš ï¸ **This happens without R explicitly telling you this is happening. We do not get a warning.**\n:::\n\n::: {.callout-note title=\"What do you think will happen if we try and add `vector_1to10` and `vector_1to3`?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# a vector reminder\nvector_1to10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nvector_1to3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# adding\nvector_1to10 + vector_1to3\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in vector_1to10 + vector_1to3: longer object length is not a multiple\nof shorter object length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  5  7  9  8 10 12 11\n```\n\n\n:::\n:::\n\n\nâš ï¸ **We see that `vector_1to3` gets recycled, but now we have a warning. We get this because the vector lengths are not divisible by each other to produce an integer. R still will perform our operation, but it tells us hey this might not be exactly what you want.**\n\n:::\n\n::: {.callout-note title=\"What do you think will happen if we try and divide `vector_1to10` by `vector_0to4`?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_1to10 / vector_0to4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]      Inf 2.000000 1.500000 1.333333 1.250000      Inf 7.000000 4.000000\n [9] 3.000000 2.500000\n```\n\n\n:::\n:::\n\n\nWe see that `vector_0to4` gets recycled, but now we have a new output we haven't seen before, `Inf` which stands for infinity/infinite.\n\nIf we are then to try and sum this vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vector_1to10 / vector_0to4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n:::\n\n\nWe get an answer of infinite. This is because we have at least one infinite value, so including it as part of a sum makes that sum infinite too.\n\nâš ï¸ **Think about how this might work if you have NAs in your vector**\n:::\n\n## Filtering vectors\n\nWe can also write code that allows us to filter our vector based on certain conditions. What if we wanted to know which observations had data where the temperature was above freezing? We could use a mathematical operator (in this case, `>`) to find instances when the statement we provide is true.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_C > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\nWhen we run this code, we get a series of values corresponding to each element of the vector, and whether or not the statement we have prompted with (`temps_C > 0`) is true or false.\n\nIf we wanted to see how many observations meet these criteria, we can take advantage of the fact that `TRUE` is coded as 1, and `FALSE` and 0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(temps_C > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nWe know then that there are 3 observations where the temperature is above freezing.\n\nIf we want to know **which** observations are above freezing, we can use the function [`which()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/which) which shows us the indices of the elements in our vector for which our code evaluates to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(temps_C > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7\n```\n\n\n:::\n:::\n\n\nThis tells us that the 5th, 6th, and 7th elements in our data have temperatures higher than freezing. In our vector we don't have the specific days associated with each temperature embedded. We can assign meta-data to our values by using the function [`names()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/names) for our vector. I'll show you how to do that below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new vector that has the dates we want to assign\ndates <- c(\"1/19\", \"1/20\", \"1/21\", \"1/22\", \"1/23\", \"1/24\", \"1/25\")\n\n# we can assign these dates as the \"names\" of our vector temps_C\nnames(temps_C) <- dates\n\n# now our temps have dates associated with them\ntemps_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      1/19       1/20       1/21       1/22       1/23       1/24       1/25 \n-3.3333333 -6.1111111 -4.4444444  0.0000000  0.5555556  5.0000000 10.5555556 \n```\n\n\n:::\n:::\n\n\nIf you knew you wanted to do this at the outset, you could create the vector along with its names all at once using the handy function [`structure()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/structure). \n\n::: {.cell}\n\n```{.r .cell-code}\n(temps_F_names <- structure(temps_F,\n                           names = dates))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1/19 1/20 1/21 1/22 1/23 1/24 1/25 \n  26   21   24   32   33   41   51 \n```\n\n\n:::\n:::\n\n\n> You can also set other attributes using the function `structure()`.\n\nYou might use the sometimes, but more likely you would want to work using a data frame.\n\n## Practice\n\n::: {.callout-note title=\"Create a vector of 10 numbers, beginning at 2, incrementing by 11. Remember, if you call `help()` or put a `?` before a function, you can learn more about its arguments and use. You might want to look back to last week's Code Club if you don't remember the simplified function for doing this.\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\na_vector <- seq(from = 2, by = 11, length.out = 10)\n\na_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   2  13  24  35  46  57  68  79  90 101\n```\n\n\n:::\n:::\n\n:::\n\n::: {.callout-note title=\"How many of these values are even? Yes I know that I haven't showed you how to do this but I am confident you can figure out how to :)\" collapse=\"true\"}\nA zero remainder means the number is even.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use modulo operator %% to see if a number is even\n# if the remainer is 0, it is even\na_vector %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 1 0 1 0 1 0 1 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# how many are even?\n10 - sum(a_vector %% 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n:::\n\n## What is a data frame?\n\n![](img/vector-vs-df.png){fig-align=\"center\" width=\"469\"}\n\nBelow I am creating a simple data frame, this is a rectangular data object with rows and columns. In reality, you will probably be reading your data in from a `.csv` or `.xlsx` file, but you can also construct a data frame directly in R. We are doing this with the function [`data.frame()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame) which is a part of base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a simple 3 by 4 data frame called small_df\n# columns are a, b, and c\n# values are numbers from 1 to 4, 5 to 8, and 9 to 12\nsmall_df <- data.frame(a = 1:4, \n                       b = 5:8, \n                       c = 9:12)\n```\n:::\n\n\nLet's look at `small_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b  c\n1 1 5  9\n2 2 6 10\n3 3 7 11\n4 4 8 12\n```\n\n\n:::\n:::\n\n\nWe can think about a data frame as being composed of a series of vectors (as columns) squished together. In the case above, each column is of the same type, integer or numeric but this doesn't have to be true. Note the first column of 1:4 is actually the row index - you can tell this as it doesn't have a column name.\n\n> Vectors all must be of the same object type (i.e., character, numeric, logical). In a data frame, each column can be a different object type. This is very useful especially when you have to have meta-data combined with numeric data.\n\nWe call use some new functions to look more at our data frame.\n\n`View()` will open our data frame like you might be used to looking at a spreadsheet in Excel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(small_df)\n```\n:::\n\n\n`str()` gives us the structure of the object x.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(small_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t4 obs. of  3 variables:\n $ a: int  1 2 3 4\n $ b: int  5 6 7 8\n $ c: int  9 10 11 12\n```\n\n\n:::\n:::\n\n\n`dim()` gives us the dimensions of x.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(small_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 3\n```\n\n\n:::\n:::\n\n\n::: {.callout-important title=\"Note that when referring to a two-dimensional piece of data, R uses the syntax [rows, columns]\"}\n:::\n\nNote, that if you use `dim()` on a vector (which has only one dimension), you will get something unexpected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this doesn't work\ndim(temps_C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\nFor a vector, instead you should use the function `length()` to figure out how many elements are in the vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this does work\nlength(temps_C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n## Performing operations on a data frame\n\nNow that we have our `small_df` we can try performing some operations on it.\n\nWhat if you wanted to take the log base 2 for every value in `small_df`? Just like we did for a vector, we can simply use the function `log2()` on `small_df`. Here I am assigning the output of this to a new data frame called `small_df_log2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(small_df_log2 <- log2(small_df))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         a        b        c\n1 0.000000 2.321928 3.169925\n2 1.000000 2.584963 3.321928\n3 1.584963 2.807355 3.459432\n4 2.000000 3.000000 3.584963\n```\n\n\n:::\n:::\n\n\nRemember, if you assign something to an object, but also want it to print at the same time, just surround the whole thing in parentheses.\n\nWhat if I wanted to take the log base 2 of only column `a`? There are a few ways I can do that.\n\n### By indexing\n\nI can use the square brackets `[]` to access certain parts of my data frame. Remember for data frames, the syntax is \\[rows, columns\\]. Let's try some example where we access by using indices (i.e., the position of the row, column, or the combination) to grab different parts of our data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first row, second column\nsmall_df[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# all rows, second column\nsmall_df[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# third row, all columns\nsmall_df[3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b  c\n3 3 7 11\n```\n\n\n:::\n:::\n\n\nIs there any difference as to the types of objects we get when doing these different types of selection? We can use the function `str()` to see what type of R object we have in the different scenarios.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first row, second column\nstr(small_df[1,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# all rows, second column\nstr(small_df[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:4] 5 6 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# third row, all columns\nstr(small_df[3,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1 obs. of  3 variables:\n $ a: int 3\n $ b: int 7\n $ c: int 11\n```\n\n\n:::\n:::\n\n\nBack to the original idea - how would we take the data only from column `a` and log base 2 transform it, but leave the rest of `small_df` as it is?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first save our df with a new name\n# this is like doing a \"save as\" for an existing df\nsmall_df_log2_a <- small_df\n\n# log2 transform the first column, and then assign that back to the first column\nsmall_df_log2_a[,1] <- log2(small_df[,1])\n\n# check to see if it worked\nsmall_df_log2_a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         a b  c\n1 0.000000 5  9\n2 1.000000 6 10\n3 1.584963 7 11\n4 2.000000 8 12\n```\n\n\n:::\n:::\n\n\nNote that column `a` now is the object type \"dbl\" or numeric, instead of \"int\" or integer, since our log2 transformation has made our values no longer integers.\n\n### By name\n\nWe can also index by providing column names - this is a nice approach since when going back to read code, a column name is often more informative than a column index/number. Note that in this case the column name `a` is in quotes since it is a character string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# all rows, the column \"a\"\nsmall_df[,\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\nWe can also use the dollar sign accessor `$` to extract an element in a data frame or list. In the case of a data frame, you are accessing a column (though you could be accessing something else if a different type of object). Note that when you type the name of a data frame, and then the \\$, R will prompt you with some possible column names.\n\n![](img/autofill-dollarsign.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\nBy using this syntax, you are turning your data frame into a vector. This may or may not be what you want to do, so just be aware.\n\n::: {.callout-tip title=\"Accessing certain observations can also be performed using the `tidyverse` functions `select()` and `filter()`. If you don't know what I'm talking about simply ignore this, we will go over it in a future Code Club.\"}\n:::\n\n## Practice\n\n::: {.callout-note title=\"Create a new data frame and assign it to the variable df. Give is 5 columns and 3 rows, and add some numbers in each of the cells, it doesn't matter what they are.\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# i'm just using different ways to creating strings of numbers \ndf <- data.frame(col_1 = c(2, 3, 4),\n                 col_2 = seq(from = 5, to = 10, by = 2.5),\n                 col_3 = 4:6,\n                 col_4 = rnorm(3, mean = 10, sd = 2),\n                 col_5 = rep(x = 6, times = 3))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  col_1 col_2 col_3     col_4 col_5\n1     2   5.0     4  8.706182     6\n2     3   7.5     5 13.453908     6\n3     4  10.0     6  7.366212     6\n```\n\n\n:::\n:::\n\n:::\n\n::: {.callout-note title=\"Multiply all of column 1 by column 2.\" collapse=\"true\"}\nHere are some different ways to do this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$col_1 * df$col_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.0 22.5 40.0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[,1] * df[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.0 22.5 40.0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[,\"col_1\"] * df[,\"col_2\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.0 22.5 40.0\n```\n\n\n:::\n:::\n\n:::\n\n::: {.callout-note title=\"Create a sixth column that is the result of the addition of columns 3 and 4.\" collapse=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_6 <- df$col_3 + df$col_4\n\nnew_df <- data.frame(df,\n                     col_6)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  col_1 col_2 col_3     col_4 col_5    col_6\n1     2   5.0     4  8.706182     6 12.70618\n2     3   7.5     5 13.453908     6 18.45391\n3     4  10.0     6  7.366212     6 13.36621\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.callout-note title=\"How does having NAs in a vector change the class of your vector?\" collapse=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_NA_1 <- c(1, 2, 3, 4, NA)\n\nclass(test_NA_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntest_NA_2 <- c(1, 2, 3, 4, \"NA\")\n\nclass(test_NA_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}