{
  "hash": "23acb53c88365cf94db9864e64650c60",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Plotting geographical maps in R: part I\"\nsubtitle: \"Using _ggplot_ to make maps and adding custom points to them\"\npagetitle: \"Maps I\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2025-02-18\"\ncategories: [maps, ggplot2, dataviz]\ntitle-block-banner: false\nnumber-depth: 2\nexecute: \n  eval: true\n  cache: false\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Intro\n\nToday is the first of three Code Club sessions on **making maps with R**.\nWe will:\n\n- Plot maps of various regions, learn how to format them, and **add points**\n  (part I, today)\n- Make **\"choropleth\" maps**, where areas are colored depending on a variable\n  like mean temperature (part II)\n- Use different **map backgrounds**, like those of Google Maps,\n  and make **interactive maps** (part III)\n\nThis content builds to some extent on the previous series of sessions on\nmaking plots with _ggplot2_, as we will mainly use this package to make maps.\n\n### Setting up\n\nWe'll load the entire tidyverse as we'll be using functions from _dplyr_\nbesides today's main pacakge, _ggplot2_.\nYou probably have the tidyverse installed already, but if not, run:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Only run this if you have not yet installed the tidyverse\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\n\nAnd to actually load it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n## Basic maps\n\n### Map data to draw states in the US\n\nWhen plotting maps, we typically need a base map that has outlines like \nadministrative borders and coastlines.\nFor today's maps,\nwe will get this type of map data through _ggplot2_'s `map_data()` function.\n\nLet's get a dataframe with the outlines of the lower 48 states of the US\n(i.e. no Alaska or Hawaii), and take a look at what it contains:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates <- map_data(map = \"state\")\n\nhead(states)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order  region subregion\n1 -87.46201 30.38968     1     1 alabama      <NA>\n2 -87.48493 30.37249     1     2 alabama      <NA>\n3 -87.52503 30.37249     1     3 alabama      <NA>\n4 -87.53076 30.33239     1     4 alabama      <NA>\n5 -87.57087 30.32665     1     5 alabama      <NA>\n6 -87.58806 30.32665     1     6 alabama      <NA>\n```\n\n\n:::\n:::\n\n\n\nEach row in this dataframe makes up a single point along the outline of a state:\n\n- The `long` and `lat` columns contain **longitudes and latitudes** in decimal\n  format.\n  In the US, all longitudes are negative as we are west of the prime meridian\n  that runs through the UK,\n  and all latitudes are positive as we are north of the equator.\n- The `group` column groups the rows (points) into **shapes/\"polygons\"** that\n  outline the borders of a state, or in some cases, parts of a state^[\n  Michigan for example, has a polygon for the lower part of the state, and one\n  for the Upper Peninsula.\n  ]. \n  (This is complemented by the `order` column which provides the drawing order.) \n- The `region` column contains the state name.\n\n![Recall: latitude (left) determines the position along the north-south axis,<br> and longitude (right) the position along the east-west axis. [Source: Wikipedia](https://commons.wikimedia.org/wiki/File:Latitude_and_Longitude_of_the_Earth.svg)](img/Latitude_and_Longitude_of_the_Earth.svg){fig-align=\"center\" width=\"70%\"}\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Our first map\n\nTo make a first map, we pass our dataframe to ggplot as per usual,\nand then use the geom **`geom_polygon()`** to draw the polygons that make up the\nstates, mapping:\n\n- Longitude (`long`, east-west axis) to the `x` aesthetic\n- Latitude (`lat`, north-south axis) to the `y` aesthetic\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=85%}\n:::\n:::\n\n\n\nThat doesn't look so good -- what could be the problem here?\n\nWe need to tell ggplot which **groups of points** together form discrete shapes\nlike an individual state's outline,\nand can do so by additionally mapping our data frame's `group` column to the\nplot's `group` aesthetic:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=85%}\n:::\n:::\n\n\n\nMuch better!\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Map projections\n\nWhen creating maps, especially for large geographic areas like the world,\ncontinents, or big countries like the US, you need to consider the \"projection\".\nWe will not go into the details of map projections here, but will note that:\n\n- Different projections are suitable for different geographic areas \n- The _ggplot_ function `coord_sf()` sets a geographic coordinate system for the\n  plot and with it's argument `crs` (Coordinate Reference System, CRS),\n  we can set the specific projection.\n- CRS projections have numbers, e.g.:\n  - `5070` is a projection suitable for the lower 48\n  - `4326` is what GPS coordinates like those in our `states` dataframe are\n    based on\n- Below, we'll use `coord_sf(crs = 5070, default_crs = 4326)`, to state that:\n  - We want to plot the map with the `5070` CRS\n  - Our data has `4326`-style GPS coordinates\n\nIn the map below, note the curvature of especially the latitudinal lines,\nwhich we didn't have before:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group)) +\n  coord_sf(crs = 5070, default_crs = 4326)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=85%}\n:::\n:::\n\n\n\n### Map theming\n\nWith maps, more basic themes like `theme_minimal()` or `theme_void()` tend to look\nbetter since we're often not that interested in the background panel and the axes.\n\n- With `theme_minimal()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Code is the same as above, just with `theme_minimal()` added:\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group)) +\n  coord_sf(crs = 5070, default_crs = 4326) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=85%}\n:::\n:::\n\n\n\n- With `theme_void()`, which omits the plotting panel and axis altogether: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Code is the same as above, just with `theme_void()` added:\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group)) +\n  coord_sf(crs = 5070, default_crs = 4326) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=85%}\n:::\n:::\n\n\n\nWhen you make many plots that should have similar theming,\na nice _ggplot_ trick is to **set an overall theme for the entire session**\nwith the `theme_set()` function,\nand optionally modify that with the `theme_update()` function.\nLet's do that here,\nso we don't have to keep adding the `theme_void()` line to every plot ---\nand we're also saying that we want any legends above the plot rather than besides\nit:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_void())\ntheme_update(legend.position = \"top\")\n```\n:::\n\n\n\nWe may also want to change the **fill and outline colors of the states** ---\nand let's save this map as an object `p` so we can build on it in the next section:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"grey85\", color = \"grey40\", linewidth = 0.1) +\n  coord_sf(crs = 5070, default_crs = 4326)\n\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=85%}\n:::\n:::\n\n\n\n::: exercise\n### {{< fa user-edit >}} Exercise 1\n\n**A)** Create a map that _does not have visible state lines_.\nWhile you're at it, you can also play around with the settings inside `geom_polygon()`\nto get a map look that you like --- or one that you hate, just for the fun of it.\nAnd how about a map with a blue panel background?\nAfter all, most (but not all) of the area surrounding the US is water.\n\n<details><summary>Click to see some examples</summary>\n\n- You can make sure that the state lines aren't visible by providing the same color\n  for the `color` and `fill` aesthetics:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"palevioletred\", color = \"palevioletred\") +\n  coord_sf(crs = 5070, default_crs = 4326)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=85%}\n:::\n:::\n\n\n\n- Why should the map look good, anyway?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"lightblue\", color = \"darkred\", linewidth = 1) +\n  coord_sf(crs = 5070, default_crs = 4326)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=85%}\n:::\n:::\n\n\n\n- A blue panel background:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"grey85\", color = \"grey40\", linewidth = 0.1) +\n  coord_sf(crs = 5070, default_crs = 4326) +\n  theme(panel.background = element_rect(fill = \"dodgerblue\", color = \"grey20\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=85%}\n:::\n:::\n\n\n  \n</details>\n\n**B)** Still using the `states` data frame as a starting point,\ncan you make a map that only shows Ohio?\nAnd/or another state or combination of neighboring states that you\nwould like to Zoom in on?\n\n<details><summary>Click to see hints</summary>\n\n- Rather than trying to zoom in by setting different axis limits,\n  try to use `filter()` to subset `states` to only Ohio (and/or other states)\n  before you pass the data to `ggplot()`.\n  \n- When plotting individual states, our current CFS does not look that great\n  as states are \"tilted\". When you're not interested in looking up a correct\n  projection, just adding `coord_sf()` with no arguments can give a reasonable look.\n\n</details>\n\n<details><summary>Click to see some examples</summary>\n\n- What are the state names like? Turns out they are all in lowercase:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(states$region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"alabama\"              \"arizona\"              \"arkansas\"            \n [4] \"california\"           \"colorado\"             \"connecticut\"         \n [7] \"delaware\"             \"district of columbia\" \"florida\"             \n[10] \"georgia\"              \"idaho\"                \"illinois\"            \n[13] \"indiana\"              \"iowa\"                 \"kansas\"              \n[16] \"kentucky\"             \"louisiana\"            \"maine\"               \n[19] \"maryland\"             \"massachusetts\"        \"michigan\"            \n[22] \"minnesota\"            \"mississippi\"          \"missouri\"            \n[25] \"montana\"              \"nebraska\"             \"nevada\"              \n[28] \"new hampshire\"        \"new jersey\"           \"new mexico\"          \n[31] \"new york\"             \"north carolina\"       \"north dakota\"        \n[34] \"ohio\"                 \"oklahoma\"             \"oregon\"              \n[37] \"pennsylvania\"         \"rhode island\"         \"south carolina\"      \n[40] \"south dakota\"         \"tennessee\"            \"texas\"               \n[43] \"utah\"                 \"vermont\"              \"virginia\"            \n[46] \"washington\"           \"west virginia\"        \"wisconsin\"           \n[49] \"wyoming\"             \n```\n\n\n:::\n:::\n\n\n\n- Plotting only Ohio -- first use `filter()` to only keep the outline for the\n  state of Ohio, then plot like before:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates |>\n  filter(region == \"ohio\") |> \n  ggplot() +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"skyblue\", color = \"grey40\", linewidth = 0.5) +\n  coord_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=85%}\n:::\n:::\n\n\n\n- Plotting Ohio along with two neighboring states:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates |>\n  filter(region %in% c(\"ohio\", \"indiana\", \"michigan\")) |> \n  ggplot() +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"azure4\", color = \"grey40\", linewidth = 0.5) +\n  coord_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Zooming in\n\nIn the exercise above, we plotted only Ohio by filtering the input data frame.\nAlternatively, we may want to zoom in to a region without considering\nadministrative borders.\nWe can do so with the `xlim` and `ylim` arguments of `coord_sf()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(states) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"grey85\", color = \"grey40\", linewidth = 0.2) +\n  # Set the x and y limits inside coord_sf:\n  coord_sf(xlim = c(-79, -89), ylim = c(35, 45)) +\n  # We may now want to draw a border around the plot since we're cutting of\n  # landmasses:\n  theme(panel.border = element_rect(fill = NA, color = \"grey20\", linewidth = 0.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=85%}\n:::\n:::\n\n\n\n<br>\n\n## Adding points and text to maps\n\n### Adding individual points and bits of text\n\nWe can add points to a map with the familiar `geom_point()` function,\nwhich we have used to make scatterplots but that can plot individual points\nas well.\n\nAs a first example, we'll just add a single point to show where the city of \nColumbus is,\nand set its coordinates on the fly (note, we're not using `aes()`).\nWe'll use the [OSU scarlet color via it's Hex code](https://bux.osu.edu/color/primary-colors/) as the color for the point:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(x = -82.99, y = 39.99, colour = \"#ba0c2f\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=85%}\n:::\n:::\n\n\n\nWe can pretty easily add arbitrary text in a similar fashion with `geom_text()`,\nin which we specify the actual text to print with the `label` argument ---\nnote that I'm subtracting `1` from the latitude so the text ends up a bit below\nthe point and not right on top of it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(x = -82.99, y = 39.99, colour = \"#ba0c2f\", size = 4) +\n  geom_text(x = -82.99, y = 39.99 - 1, label = \"Columbus\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=85%}\n:::\n:::\n\n\n\n::: {.callout-tip}\n#### Adding individual points and pieces of text with _ggplot_\nWhile in \"regular\" (non-map) ggplots, we usually plot plot points based on\ninformation in a data frame with `geom_point()`,\nadding individual points and text _can_ be done in the exact same way with regular\nggplots, and can occasionally be useful.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Adding a set of points from a data frame\n\nIn your research, you may want to make a map that plots sampling locations.\nAs a simple fictional example,\nwe can create a dataframe with four sampling locations, a grouping factor\n(`season`), and a column with a numerical result for each location (`yield`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocations <- data.frame(\n  location = c(\"L01\", \"L02\", \"L03\", \"L04\"),\n  long = c(-80, -100, -90, -110),\n  lat = c(35, 33, 45, 43),\n  season = c(\"winter\", \"winter\", \"summer\", \"summer\"),\n  yield = c(21, 94, 39, 62)\n)\n\nlocations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  location long lat season yield\n1      L01  -80  35 winter    21\n2      L02 -100  33 winter    94\n3      L03  -90  45 summer    39\n4      L04 -110  43 summer    62\n```\n\n\n:::\n:::\n\n\n\nNow, we can add a layer to our saved plot `p` with the sampling locations ---\nnote that:\n\n- We are giving `geom_point()` \"it's own\" data set with the `data =` argument\n- We map the `fill` aesthetic to the `season` column so we can distinguish\n  samples from different seasons\n- We use point shape 21\n  (see [this overview of R point shapes](https://www.sthda.com/english/wiki/ggplot2-point-shapes)) which allows\n  for a `fill` color as well as an outline color (the latter via `color`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(data = locations,\n             aes(x = long, y = lat, fill = season),\n             size = 4, shape = 21)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=85%}\n:::\n:::\n\n\n\n::: exercise\n### {{< fa user-edit >}} Exercise 2\n\nBuild on the previous map by making the appearance of the sampling location points\nreflect the values in the `yield` column.\nFor example, higher yields could produce larger points, or the fill color of the\npoints could depend on the yield.\n\n<details><summary>Click here for some hints</summary>\n\n- To make points vary in size, use the `size` aesthetic `aes(size = ...)`\n\n- To make points vary in fill color, use the `fill` aesthetic and then switch to\n  a different aesthetic for `season`, like point `shape`.\n\n</details>\n\n<details><summary>Click here for possible solutions with point size</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + \n  geom_point(data = locations,\n             aes(x = long, y = lat, fill = season, size = yield),\n             shape = 21)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=85%}\n:::\n:::\n\n\n\nThat produces quite a small point for the location with the lowest yield --\nwe could restrict the size range of the points like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + \n  geom_point(data = locations,\n             aes(x = long, y = lat, fill = season, size = yield),\n             shape = 21) +\n  scale_size_continuous(range = c(2.5, 6))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n<details><summary>Click here for possible solutions with point fill color</summary>\n\nIf we want to use `fill` color instead for `yield`,\nwe'll need another aesthetic for `season`, e.g. `shape`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + \n  geom_point(data = locations,\n             aes(x = long, y = lat, shape = season, fill = yield),\n             size = 4) +\n  # Make sure the shapes support a fill color (the default ones don't):\n  scale_shape_manual(values = c(21, 23))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=85%}\n:::\n:::\n\n\n\nWe can change the fill color scale to one of the\n[viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)\ncolor scales:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + \n  geom_point(data = locations,\n             aes(x = long, y = lat, shape = season, fill = yield),\n             size = 4) +\n  # Make sure the shapes support a fill color (the default ones don't):\n  scale_shape_manual(values = c(21, 23)) +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n:::\n\n<br>\n\n## More examples --- with Ohio\n\nThe background map we've been working with so far doesn't have county lines.\nEspecially if we want to make a map of single state like Ohio,\nthose would come in handy.\n\n### Getting county-level map data for just Ohio\n\nWe can get a county-level map of the entire United States using\n`map_data(map = \"county\")`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_data(map = \"county\") |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order  region subregion\n1 -86.50517 32.34920     1     1 alabama   autauga\n2 -86.53382 32.35493     1     2 alabama   autauga\n3 -86.54527 32.36639     1     3 alabama   autauga\n4 -86.55673 32.37785     1     4 alabama   autauga\n5 -86.57966 32.38357     1     5 alabama   autauga\n6 -86.59111 32.37785     1     6 alabama   autauga\n```\n\n\n:::\n:::\n\n\n\nLet's filter that so we are only left with Ohio:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio <- map_data(map = \"county\") |>\n  filter(region == \"ohio\")\n\nhead(ohio)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order region subregion\n1 -83.66902 39.02989  2012 59960   ohio     adams\n2 -83.56590 39.02989  2012 59961   ohio     adams\n3 -83.37109 39.06426  2012 59962   ohio     adams\n4 -83.30806 39.06426  2012 59963   ohio     adams\n5 -83.30233 39.05280  2012 59964   ohio     adams\n6 -83.25649 39.01842  2012 59965   ohio     adams\n```\n\n\n:::\n:::\n\n\n\nLet's get a feel for what's in the resulting dataframe --- the only `region`\n(i.e. state) should be `ohio`, and `subregion`s are counties:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio |> count(region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  region    n\n1   ohio 1427\n```\n\n\n:::\n\n```{.r .cell-code}\nohio |> count(subregion) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  subregion  n\n1     adams 17\n2     allen 16\n3   ashland 17\n4 ashtabula 11\n5    athens 19\n6  auglaize 16\n```\n\n\n:::\n:::\n\n\n\nThe number of entries for each county is simply how many points make up the lines. Those numbers are quite low making this a relatively low-resolution map ---\nbut good enough for our purposes.\n\n### A base map of Ohio\n\nNow we are ready to plot our map of Ohio:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio <- ggplot(ohio) +\n  geom_polygon(aes(x = long, y = lat, group = group),\n               fill = \"grey90\", color = \"grey70\") +\n  coord_sf()\n\np_ohio\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=85%}\n:::\n:::\n\n\n\nWe can now use this as a **base map** to plot points on,\nlike we did above with the US map.\nOr we could create a map where counties differ in fill color depending on some\nvariable, like the number of farms or eagle nests in each county.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Adding county names\n\nFor now, without pulling in additional data,\nsay that we want to **print the county names in the map**.\n\nTo do so, we will start by transforming the county names to **\"Title Case\"**\nfrom the original all-lowercase using the `tools::toTitleCase()` function ---\nand let's also use the name `county` (instead of `subregion` for that new column):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio <- ohio |> mutate(county = tools::toTitleCase(subregion))\n```\n:::\n\n\n\nWe'd also need a _single pair of coordinates for each county_,\nbecause we only want to print each county name once.\nA quick-and-dirty way to get those is to simply compute the **mean** of the\nlongitude and latitude of the points in the dataframe that make up the borders.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_coords <- ohio |>\n  summarize(long = mean(long), lat = mean(lat), .by = county)\n\nhead(county_coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     county      long      lat\n1     Adams -83.46984 38.82059\n2     Allen -84.12130 40.79424\n3   Ashland -82.29662 40.86571\n4 Ashtabula -80.75319 41.80821\n5    Athens -81.98483 39.35768\n6  Auglaize -84.20080 40.54607\n```\n\n\n:::\n:::\n\n\n\nNow, we can add the county labels to the plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_text(data = county_coords,\n            aes(x = long, y = lat, label = county),\n            color = \"darkblue\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=85%}\n:::\n:::\n\n\n\nThat's not perfect (those \"mean coordinates\" are not actual centroids),\nbut not bad for a quick-and-dirty attempt!\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Exercise 3\n\n**A)** OSU has campuses in the following places:\n\n- Columbus, Franklin County\n- Wooster, Wayne County\n- Lima, Allen County\n- Mansfield, Richland County\n- Marion, Marion County\n- Newark, Licking County\n\nCan you create a map similar to our previous one,\nbut then with only these 6 counties labeled by name?\nLike in the example below:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>Click here for some hints</summary>\n\n- You'll have to `filter()` the `county_coords` data frame to only keep the \n  counties of interest.\n  \n- After that, the plotting code will be identical to that for the previous map,\n  just make sure you pass the correct, filtered data frame.\n\n- If you're printing the names of the counties, then you won't want a `fill`\n  legend: you can turn that off using `guides(fill = \"none\")`.\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n- First we filter the `county_coords` to only keep our focal counties,\n  and store the result in a new data frame:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal_counties <- c(\"Franklin\", \"Wayne\", \"Allen\",\n                    \"Richland\", \"Marion\", \"Licking\") \n\ncounty_coords_sel <- county_coords |>\n  filter(county %in% focal_counties)\n```\n:::\n\n\n\n- We use the same plotting code as before, but now with `county_coords_sel`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_text(data = county_coords_sel,\n            aes(x = long, y = lat, label = county),\n            color = \"darkblue\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n<br>\n\n**B) (Bonus)** Can you produce a map that has a different fill color for each\ncounty, like the one below?\n\n\n\n::: {.cell .preview-image}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>Click here for some hints</summary>\n\n- You'll want to keep the original `geom_polygon()` layer with the gray counties,\n  and then add a **second** `geom_polygon()` layer just with the focal counties.\n  \n- In that second layer, map the `county` column to the `fill` aesthetic.\n\n- Make sure to add the `geom_text()` layer last,\n  or it would be masked by the polygon layer.\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_polygon(data = ohio |> filter(county %in% focal_counties),\n               aes(x = long, y = lat, group = group, fill = county),\n               color = \"grey70\") +\n  geom_text(data = county_coords_sel,\n            aes(x = long, y = lat, label = county),\n            color = \"darkblue\", size = 4) +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=85%}\n:::\n:::\n\n\n</details>\n\n:::\n\n<br>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}