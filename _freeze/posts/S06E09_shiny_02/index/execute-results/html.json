{
  "hash": "13916199619828da67a0dc781e49aba9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny 02: Intro to Shiny (cont.)\"\nsubtitle: Explore additional features in Shiny App.\nauthor: \"Horacio Lopez-Nicora\"\ndate: \"2023-11-06\"\ncategories: [shiny, quarto]\ntitle-block-banner: false\nimage: img/shiny_logo.png\ndf-print: kable\ncode-fold: false\n---\n\n\nWelcome to our `shiny` app development class! Throughout this session, we will continue diving into the world of Shiny and explore its incredible potential for creating interactive web applications. Today we will use the function `reactiveVal`.\n\n## Shiny App to collect data.\n\nThe `reactiveVal` function is utilized to create a \"reactive value\" object which has special capabilities for reactive programming. It serves as a variable that allows both reading and writing of values. Whenever the value is read from a `reactiveVal` object, the calling reactive expression becomes dependent on it. Similarly, when the value is altered, any reactives that were previously dependent on it are notified.\n\nLet's make a `shiny` app and see how this works!  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install and call the following packages.\nlibrary(shiny)\nlibrary(DT)\n\n# Initialize an empty data frame to store the collected data\ncollected_data <- data.frame(\n  Treatment = character(0),\n  PlotNumber = numeric(0),\n  StandCount = numeric(0),\n  PlantHeight = numeric(0),\n  Severity = numeric(0)\n)\n\n# Create a variable to store the selected rows\nselected_rows <- reactiveVal()\n\n# Define the UI\nui <- fluidPage(\n  titlePanel(\"Soybean Field Data Collection\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"treatment\", \"Select Treatment:\", c(\"T1\", \"T2\", \"T3\")),\n      numericInput(\"plot\", \"Enter Plot Number:\", value = 101, min = 101, max = 304),\n      numericInput(\"stand_count\", \"Enter Stand Count:\", value = 0),\n      numericInput(\"plant_height\", \"Enter Plant Height (in cm):\", value = 0),\n      numericInput(\"severity\", \"Enter Severity Rating:\", value = 0),\n      actionButton(\"submit\", \"Submit Data\"),\n      actionButton(\"delete\", \"Delete Selected Row\"),\n      downloadButton(\"downloadData\", \"Download Data\")\n    ),\n    \n    mainPanel(\n      DTOutput(\"dataTable\")\n    )\n  )\n)\n\n# Define the server\nserver <- function(input, output, session) {\n  collected_data_reactive <- reactiveVal(NULL)\n  \n  observeEvent(input$submit, {\n    new_entry <- data.frame(\n      Treatment = input$treatment,\n      PlotNumber = input$plot,\n      StandCount = input$stand_count,\n      PlantHeight = input$plant_height,\n      Severity = input$severity\n    )\n    # Append the new entry to the collected data\n    collected_data <- rbind(collected_data_reactive(), new_entry)\n    collected_data_reactive(collected_data)\n    \n    # Reset input fields\n    updateSelectInput(session, \"treatment\", selected = \"T1\")\n    updateNumericInput(session, \"plot\", value = 101)\n    updateNumericInput(session, \"stand_count\", value = 0)\n    updateNumericInput(session, \"plant_height\", value = 0)\n    updateNumericInput(session, \"severity\", value = 0)\n  })\n  \n  observeEvent(input$delete, {\n    # Get the selected row(s) and remove them from the collected data\n    selected_rows(input$dataTable_rows_selected)\n    if (length(selected_rows()) > 0) {\n      collected_data <- collected_data_reactive()\n      collected_data <- collected_data[-selected_rows(), ]\n      collected_data_reactive(collected_data)\n    }\n  })\n  \n  output$dataTable <- renderDT({\n    datatable(collected_data_reactive(), options = list(select = \"multi\"))\n  })\n  \n  # Download data as a CSV file\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      \"collected_data.csv\"\n    },\n    content = function(file) {\n      write.csv(collected_data_reactive(), file)\n    }\n  )\n}\n\n# Run the app\nshinyApp(ui, server)\n```\n:::\n\n\nNow that we have successfully developed a `shiny` app for data collection, we can now proceed to working on another app designed for processing the collected data.\n\n## Shiny App to process collected data.\n\nWe will use `shinyjs` and `ggstatsplot` to generate a `shiny` app that will use collected data to process and generate some preliminary data viz and descriptive stats. For this you will need to use `.csv` file **Aggressiveness_Zone.csv** that was sent to your email.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required libraries\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggstatsplot)\nlibrary(shinyjs)\n\n# Define UI\nui <- fluidPage(\n  useShinyjs(),\n  titlePanel(\"Summary Statistics and Plots\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file\", \"Choose CSV File\"),\n      selectInput(\"plotType\", \"Select Plot Type\",\n                  c(\"Box-violin Plot\", \"Box Plot\", \"Violin Plot\")),\n      \n      # Add options to modify axis label and tick label size\n      sliderInput(\"axisLabelSize\", \"Axis Label Size\", min = 8, max = 20, value = 12),\n      sliderInput(\"axisTickLabelSize\", \"Axis Tick Label Size\", min = 8, max = 20, value = 10)\n    ),\n    \n    mainPanel(\n      tabsetPanel(\n        tabPanel(\"Summary Statistics\", tableOutput(\"summaryTable\")),\n        tabPanel(\"Plots\", plotOutput(\"plot\"))\n      )\n    )\n  )\n)\n\n# Define server\nserver <- function(input, output) {\n  data <- reactive({\n    inFile <- input$file\n    if (is.null(inFile)) return(NULL)\n    read.csv(inFile$datapath)\n  })\n  \n  # Define plot_type in the global scope\n  plot_type <- reactive({\n    if (!is.null(data())) {\n      switch(input$plotType,\n             \"Box-violin Plot\" = {\n               ggstatsplot::ggbetweenstats(data(), x = AEZ, y = RF, messages = FALSE)\n             },\n             \"Box Plot\" = ggplot(data(), aes(x = AEZ, y = RF, fill = AEZ)) +\n               geom_boxplot() +\n               scale_fill_brewer(palette = \"Set1\") +\n               theme(axis.text.x = element_text(size = input$axisTickLabelSize),\n                     axis.text.y = element_text(size = input$axisTickLabelSize),\n                     axis.title.x = element_text(size = input$axisLabelSize),\n                     axis.title.y = element_text(size = input$axisLabelSize))\n             ,\n             \"Violin Plot\" = ggplot(data(), aes(x = AEZ, y = RF, fill = AEZ)) +\n               geom_violin() +\n               geom_point(aes(x = AEZ, y = RF), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 2) +\n               stat_summary(aes(group = AEZ), fun.data = mean_cl_boot, geom = \"crossbar\", width = 0.5) +\n               scale_fill_brewer(palette = \"Set2\") +\n               theme(axis.text.x = element_text(size = input$axisTickLabelSize),\n                     axis.text.y = element_text(size = input$axisTickLabelSize),\n                     axis.title.x = element_text(size = input$axisLabelSize),\n                     axis.title.y = element_text(size = input$axisLabelSize))\n      )\n    }\n  })\n  \n  output$summaryTable <- renderTable({\n    if (is.null(data())) return(NULL)\n    summary_stats <- data() %>%\n      group_by(AEZ) %>%\n      summarize(\n        Mean = mean(RF),\n        Standard_Deviation = sd(RF),\n        Standard_Error = sd(RF) / sqrt(n())\n      )\n    as.data.frame(summary_stats)\n  })\n  \n  output$plot <- renderPlot({\n    plot_type()\n  })\n}\n\n# Run the application\nshinyApp(ui, server)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}