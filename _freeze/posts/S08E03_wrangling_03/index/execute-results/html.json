{
  "hash": "f793b0e5c3d58f091822e4075be5e6b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Wrangling 3: Summarizing Data by Group\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2024-09-16\"\ncategories: [r-basics, tidyverse]\ntitle-block-banner: false\nnumber-depth: 3\neditor_options:\n  chunk_output_type: console\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\n    class-output: styled-output\n---\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Introduction\n\n#### Recap of the past two weeks\n\nIn the past two weeks, we've been learning about the following functions\nfrom the _dplyr_ package, a central workhorse of the tidyverse ecosystem,\nto manipulate data in data frames:\n\n- `filter()` to pick rows (which typically represent observations/samples/individuals)\n- `select()` to pick columns (which typically represent variables/properties)\n- `arrange()` to sort data frame rows\n- `mutate()` to add and manipulate data frame columns\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Learning objectives for today\n\nToday, our main focus is another very useful _dplyr_ function:\n`summarize()` to compute summaries across rows, typically across **groups of rows**.\n\nBut we will start with an introduction to a new dataset,\nthe `count()` function, and dealing with missing data.\n\nAnd if we get to it,\nwe will learn about the `slice_()` family of functions,\nto pick rows but in a different manner than with `filter()`.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Setting up\n\nLoad the _tidyverse_ meta-package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n::: {.callout-warning collapse=\"true\"}\n#### Still need to install the tidyverse? _Click here for instructions_\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n:::\n\n<br>\n\n## A penguins dataset\n\nThe data set we will use today is from the\n[`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/index.html) package,\nwhich contains a data set on 🐧 collected by Dr. Kristen Gorman at the\nPalmer Station Antarctica.\n\nIt is a nice, relatively simple data set to practice data exploration and\nvisualization in R.\n\n![Illustration by [Allison Horst](https://allisonhorst.github.io/palmerpenguins/articles/art.html)](img/palmerpenguins_hex.png){width=50%}\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Installing and loading the package\n\nWe'll have to install that package first, which should be quick:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"palmerpenguins\")\n```\n:::\n\n\nNow we're ready to load the package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Taking a look at the data set\n\nOnce you've loaded the _palmerpenguins_ package,\nyou will have a data frame called `penguins` at your disposal ---\nlet's take a look:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nIn this data set, **each row represents an individual penguin** for which we know\nthe `species`, `sex`, `island` of origin, and for which, across several `year`s,\nwe have a set of size measurements:\n\n- Bill length in mm (`bill_length_mm` column)\n- Bill depth in mm (`bill_depth_mm` column)\n- Flipper length in mm (`flipper_length_mm` column)\n- Body mass in grams (`body_mass_g` column)\n\nHere's a visual for what the two bill measurements represent:\n\n![](img/culmen_depth.png){fig-align=\"center\" width=70%}\n\n<br>\n\n## Exploring data with the `count()` function\n\nTo orient yourself a bit more to this dataset, you may want to see, for example,\nhow many species and how many islands are in it, and how frequently each occur.\n\nIn other words, we may want to produce a few \"count tables\",\nwhich is a common part of Exploratory Data Analysis (EDA).\nWe can do this with the _dplyr_ function \n[`count()`](https://dplyr.tidyverse.org/reference/count.html):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 2\n  species       n\n  <fct>     <int>\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 2\n  island        n\n  <fct>     <int>\n1 Biscoe      168\n2 Dream       124\n3 Torgersen    52\n```\n\n\n:::\n:::\n\n\nOK, so we have 3 species of penguin and 3 island. Which species occur on which islands?\nWe can answer this by simply specifying both columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(species, island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 5 × 3\n  species   island        n\n  <fct>     <fct>     <int>\n1 Adelie    Biscoe       44\n2 Adelie    Dream        56\n3 Adelie    Torgersen    52\n4 Chinstrap Dream        68\n5 Gentoo    Biscoe      124\n```\n\n\n:::\n:::\n\n\n<details><summary>Why are not all possible combinations of `species` and `island` shown here?</summary>\nSome `species` do not appear to occur on (or at least haven't been sampled on)\ncertain `island`s. These zero-counts are not show, or \"dropped, by default.\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nTo **show zero-count combinations**, add `.drop = FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(species, island, .drop = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 9 × 3\n  species   island        n\n  <fct>     <fct>     <int>\n1 Adelie    Biscoe       44\n2 Adelie    Dream        56\n3 Adelie    Torgersen    52\n4 Chinstrap Biscoe        0\n5 Chinstrap Dream        68\n6 Chinstrap Torgersen     0\n7 Gentoo    Biscoe      124\n8 Gentoo    Dream         0\n9 Gentoo    Torgersen     0\n```\n\n\n:::\n:::\n\n\nFinally, you can **sort the output by the count** using `sort = TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(species, island, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 5 × 3\n  species   island        n\n  <fct>     <fct>     <int>\n1 Gentoo    Biscoe      124\n2 Chinstrap Dream        68\n3 Adelie    Dream        56\n4 Adelie    Torgersen    52\n5 Adelie    Biscoe       44\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n:::{.callout-tip collapse=\"true\"}\n#### Side note: Base R's `table()` function _(Click to expand)_\n\nAlso worth mentioning is the base R `table()` function, which is similar to `count()`.\nWhile its output format is unwieldy for follow-up analyses,\nyou may prefer its formatting especially when wanting to glance at a 2-way\ncount table to see patterns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(penguins$species, penguins$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n           \n            Biscoe Dream Torgersen\n  Adelie        44    56        52\n  Chinstrap      0    68         0\n  Gentoo       124     0         0\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nAdditionally, as a _dplyr_ function, `count()` only works with data frames.\nYou may sometimes need to create a count table for a **vector**,\nand `table()` can do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_vector <- penguins$species\ntable(species_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\nspecies_vector\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n```\n\n\n:::\n:::\n\n:::\n\n<br>\n\n## Missing data\n\nLet's compute the mean bill length across all penguins:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(penguins$bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] NA\n```\n\n\n:::\n:::\n\n\n<details><summary>What does `NA` mean and why are we getting this?</summary>\n\n`NA` means \"not any\" and is R's way of representing missing data.\nWhen a computation in R returns `NA`, this means that some of the values used\nmust themselves have been `NA`.\nIn other words, one or more of the values in the `bill_length_mm` columns are\n`NA`: perhaps the penguin in question got away before its bill was measured.\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nWe can overcome this by setting the argument `na.rm` (\"NA-remove\") to `TRUE` --\nand note that this argument is available in many functions in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(penguins$bill_length_mm, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 43.92193\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nLet's find the penguins with a missing bill length measurement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(is.na(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 2 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen             NA            NA                NA          NA\n2 Gentoo  Biscoe                NA            NA                NA          NA\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n<br>\n\n::: exercise\n\n## Exercises I\n\n### `count()`\n\n**A)** Use `count()` to get the number of penguins for each combination of\n       `species`, `year` and `sex`.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> count(species, year, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 22 × 4\n   species    year sex        n\n   <fct>     <int> <fct>  <int>\n 1 Adelie     2007 female    22\n 2 Adelie     2007 male      22\n 3 Adelie     2007 <NA>       6\n 4 Adelie     2008 female    25\n 5 Adelie     2008 male      25\n 6 Adelie     2009 female    26\n 7 Adelie     2009 male      26\n 8 Chinstrap  2007 female    13\n 9 Chinstrap  2007 male      13\n10 Chinstrap  2008 female     9\n# ℹ 12 more rows\n```\n\n\n:::\n:::\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** What is the least common combination of `species` and `sex`\nfor penguins weighing less than 4,000 grams?\n\n<details><summary><b>Hint</b> (click here)</summary>\nYou'll have to `filter()` first.\n</details>\n\n<details><summary><b>Solution</b> (click here)</summary>\n\nThe least common combination among such light-weight penguins is female Gentoo,\nof which there is only 1.\nOr you may also argue that the answer should be male Gentoo,\nof which there are none:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(body_mass_g < 4000) |> \n  count(species, sex, .drop = FALSE, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 7 × 3\n  species   sex        n\n  <fct>     <fct>  <int>\n1 Adelie    female    73\n2 Adelie    male      35\n3 Chinstrap female    33\n4 Chinstrap male      19\n5 Adelie    <NA>       4\n6 Gentoo    female     1\n7 Gentoo    male       0\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n### Removing rows with missing data\n\nFor the sake of convenience, we will here remove these two penguins that don't\nseem to have had _any_ measurements taken^[\nRemoving rows with `NA`s _may_ be appropriate for your own data too,\nbut this will depend on the context!].\n\n**A**) Do so by storing the output of an appropriate `filter()` operation in a\n       new data frame `penguins_noNA`.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA <- penguins |>\n  filter(!is.na(bill_length_mm))\n```\n:::\n\n</details>\n\n**B**) Check how many penguins (rows) were removed.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n2 rows should have been removed.\n\nThere are many ways to check this!\nYou can simply look for these objects in the\nEnvironment pane, print them to screen, or use the `nrow()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 344\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(penguins_noNA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 342\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(penguins) - nrow(penguins_noNA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 2\n```\n\n\n:::\n:::\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip collapse=\"true\"}\n#### Side note: Checking and removing all columns with missing data _(Click to expand)_\n\nYou can see rows with missing data in _any_ column, regardless of how many there\nare in total, using the `if_any()` helper function of `filter()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(if_any(everything(), is.na)) |>\n  select(-body_mass_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 11 × 7\n   species island    bill_length_mm bill_depth_mm flipper_length_mm sex    year\n   <fct>   <fct>              <dbl>         <dbl>             <int> <fct> <int>\n 1 Adelie  Torgersen           NA            NA                  NA <NA>   2007\n 2 Adelie  Torgersen           34.1          18.1               193 <NA>   2007\n 3 Adelie  Torgersen           42            20.2               190 <NA>   2007\n 4 Adelie  Torgersen           37.8          17.1               186 <NA>   2007\n 5 Adelie  Torgersen           37.8          17.3               180 <NA>   2007\n 6 Adelie  Dream               37.5          18.9               179 <NA>   2007\n 7 Gentoo  Biscoe              44.5          14.3               216 <NA>   2007\n 8 Gentoo  Biscoe              46.2          14.4               214 <NA>   2008\n 9 Gentoo  Biscoe              47.3          13.8               216 <NA>   2009\n10 Gentoo  Biscoe              44.5          15.7               217 <NA>   2009\n11 Gentoo  Biscoe              NA            NA                  NA <NA>   2009\n```\n\n\n:::\n:::\n\n\n(I removed the `body_mass_g` column just to be able to fit the `sex` column on\nthe webpage, which is where the `NA`s are.)\n\nBy just adding a `!` to the above code, you can therefore remove any rows with\nany missing data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA2a <- penguins |>\n  filter(!if_any(everything(), is.na))\n```\n:::\n\n\nThough it is also worth noting that there is a specialized base R function\navailable for this as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA2b <- na.omit(penguins)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(penguins)         # The original data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 344\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(penguins_noNA)    # Without the 2 penguins with missing measurements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 342\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(penguins_noNA2a)  # Without all rows with missing data, using filter()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 333\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(penguins_noNA2b)  # Without all rows with missing data, using na.omit()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n[1] 333\n```\n\n\n:::\n:::\n\n:::\n\n<br>\n\n## The `summarize()` function\n\nThe [`summarize()` function from the _dplyr_ package](https://dplyr.tidyverse.org/reference/summarise.html)\ncan compute across-row data summaries.\nAs a first example,\nhere's how you can compute the overall mean bill length with this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  summarize(bill_len_mean = mean(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 1 × 1\n  bill_len_mean\n          <dbl>\n1          43.9\n```\n\n\n:::\n:::\n\n\nAs you can see, this function has quite a different output from the _dplyr_ functions we'd seen so far.\nAll of those returned a manipulated version of our original dataframe,\nwhereas `summarize()` returns a \"completely new\" dataframe with a summary of the original data.\n\nHowever, summarizing _across all rows at once_ with `summarize()` is much more verbose\nthan the simple \"base R\" solution we saw above (`mean(penguins_noNA$bill_length_mm)`).\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Summarizing by group \n\nThe real power of `summarize()` comes with its ability to compute **group-wise summaries**.\nFor example, simply by adding `.by = species`,\nit will calculate the mean bill length separately for each species:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  summarize(bill_len_mean = mean(bill_length_mm), .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 2\n  species   bill_len_mean\n  <fct>             <dbl>\n1 Adelie             38.8\n2 Gentoo             47.5\n3 Chinstrap          48.8\n```\n\n\n:::\n:::\n\n\nNice! We can also compute multiple summarized variables ---\nand use summarizing functions other than `mean()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  summarize(bill_len_mean = mean(bill_length_mm),\n            bill_len_max = max(bill_length_mm),\n            bill_len_min = min(bill_length_mm),\n            .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 4\n  species   bill_len_mean bill_len_max bill_len_min\n  <fct>             <dbl>        <dbl>        <dbl>\n1 Adelie             38.8         46           32.1\n2 Gentoo             47.5         59.6         40.9\n3 Chinstrap          48.8         58           40.9\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Including group counts\n\nA handy helper function is **`n()`**, which will compute the **number of rows for each group**\n(i.e. the group sizes, which can be good to know,\nfor example so you don't make unfounded conclusions based on really small sample sizes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  summarize(bill_depth_mean = mean(bill_depth_mm),\n            n_penguins = n(),\n            .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 3\n  species   bill_depth_mean n_penguins\n  <fct>               <dbl>      <int>\n1 Adelie               18.3        151\n2 Gentoo               15.0        123\n3 Chinstrap            18.4         68\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Common summary statistic functions\n\nHere is an overview of the most commonly used functions to compute summaries:\n\n- `mean()` & `median()`\n- `min()` & `max()`\n- `sum()`\n- `sd()`: standard deviation\n- `IQR()`: interquartile range\n- `n()`: counts the number of rows (observations)\n- `n_distinct()`: counts the number of distinct (unique) values\n\nTwo final comments about `summarize()`:\n\n- You can also ask `summarize()` to compute summaries by **multiple columns**,\n  which will return separate summaries for each _combination_ of the involved variables ---\n  we'll see this in the exercises.\n\n- This may be obvious, but whatever column you are computing summaries by\n  (using `.by`) should be a **categorical variable**.\n  In our `diamond` examples, we're only using columns that are `factor`s,\n  but \"regular\" `character` columns will work just fine as well.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip collapse=\"true\"}\n### Side note: `group_by()` _(Click to expand)_\n\nThe \"classic\" way of using `summarize()` with multiple groups is by preceding\nit with a `group_by()` call ---\ne.g., the code below is equivalent to our last example above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  group_by(species) |> \n  summarize(bill_depth_mean = mean(bill_depth_mm),\n            n_penguins = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 3\n  species   bill_depth_mean n_penguins\n  <fct>               <dbl>      <int>\n1 Adelie               18.3        151\n2 Chinstrap            18.4         68\n3 Gentoo               15.0        123\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nThe `.by` argument to `summarize()` (and other functions!) is a rather recent addition,\nbut I prefer it over `group_by()`:\n\n- It is simpler, a bit less typing, and makes the `summarize()` call self-contained\n- When grouping by multiple columns, `group_by()` has some odd, unhelpful behavior\n  where it keeps some of the groupings, such that you likely need an `ungroup()` call as well.\n\n:::\n\n<br>\n\n::: exercise\n## Exercises II\n\n### Means across variables\n\nCompute the per-species means for all 4 size-related variables.\n\nDo all these variables co-vary, such that, for example,\none species is the largest for each measurement?\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  summarize(bill_len = mean(bill_length_mm),\n            bill_dep = mean(bill_depth_mm),\n            flip_len = mean(flipper_length_mm),\n            body_mass = mean(body_mass_g),\n            .by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 5\n  species   bill_len bill_dep flip_len body_mass\n  <fct>        <dbl>    <dbl>    <dbl>     <dbl>\n1 Adelie        38.8     18.3     190.     3701.\n2 Gentoo        47.5     15.0     217.     5076.\n3 Chinstrap     48.8     18.4     196.     3733.\n```\n\n\n:::\n:::\n\n\nThe variables seem to largely co-vary across species, but bill depth stands out:\nthe large Gentoo penguins have less deep bills than the other two species.\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Summaries across multiple groups\n\nFor Adelie penguins only, find the combination of `island` and `year` on which\nthe lightest penguins were found, on average.\n\nFor this, you'll have to group by both abovementioned columns.\nSee if you can figure this out by yourself first,\nbut check out the grouping hint below if you can't get that part to work.\n\n<details><summary><b>Grouping hint</b> (click here)</summary>\n`.by = c(island, year)` will group by these 3 columns at once.\n</details>\n\n<details><summary><b>More hints</b> (click here)</summary>\n\n- `filter()` before you summarize.\n- `arrange()` after you summarize.\n\n</details>\n\n<details><summary><b>Solution</b> (click here)</summary>\n\nAfter summarizing, it makes sense to arrange mean mass,\nso you can see the \"lightest species-island combinations\" first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  filter(species == \"Adelie\") |> \n  summarize(mass_mean = mean(body_mass_g),\n            .by = c(island, year)) |>\n  arrange(mass_mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 9 × 3\n  island     year mass_mean\n  <fct>     <int>     <dbl>\n1 Torgersen  2009     3489.\n2 Biscoe     2007     3620 \n3 Biscoe     2008     3628.\n4 Dream      2009     3651.\n5 Dream      2007     3671.\n6 Dream      2008     3756.\n7 Torgersen  2007     3763.\n8 Torgersen  2008     3856.\n9 Biscoe     2009     3858.\n```\n\n\n:::\n:::\n\n\n</details>\n\n:::\n\n<br>\n\n## The `slice_` functions\n\nLike the `filter()` function,\n[functions in the `slice_` family](https://dplyr.tidyverse.org/reference/slice.html)\nselect specific rows,\nbut have some different functionality that's quite handy ---\nespecially in combination with grouping.\n\nLet's say we wanted to only get, **for each `species`, the lightest penguin**.\nWe can do this pretty easily with the `slice_max()` function,\nwhich will return the row(s) with the highest value for a specified variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  slice_min(body_mass_g, by = species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 4 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Adelie    Biscoe           36.5          16.6               181        2850\n2 Adelie    Biscoe           36.4          17.1               184        2850\n3 Gentoo    Biscoe           42.7          13.7               208        3950\n4 Chinstrap Dream            46.9          16.6               192        2700\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n<details><summary>Why are we getting more than one penguin per `species` in some cases? _(Click to see the answer)_</summary>\nBecause of ties in the `body_mass_g` value. (We'll get back to this in the next set of exercises.)\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nYou can get more than just the single highest (`slice_max()`) / lowest (`slice_min()`)\nvalue per group with the `n=` argument,\nand can get a specific proportion of rows with `prop=`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the 3 penguins with the longest flippers for each year:\npenguins_noNA |>\n  slice_max(flipper_length_mm, by = year, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 10 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           50            16.3               230        5700\n 2 Gentoo  Biscoe           59.6          17                 230        6050\n 3 Gentoo  Biscoe           48.7          15.1               222        5350\n 4 Gentoo  Biscoe           47.3          15.3               222        5250\n 5 Gentoo  Biscoe           54.3          15.7               231        5650\n 6 Gentoo  Biscoe           49.8          16.8               230        5700\n 7 Gentoo  Biscoe           48.6          16                 230        5800\n 8 Gentoo  Biscoe           52.1          17                 230        5550\n 9 Gentoo  Biscoe           51.5          16.3               230        5500\n10 Gentoo  Biscoe           55.1          16                 230        5850\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the 2% narrowest-billed penguins for each sex\npenguins_noNA |>\n  slice_min(bill_depth_mm, by = sex, prop = 0.02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n1 Gentoo  Biscoe           48.5          14.1               220        5300\n2 Gentoo  Biscoe           51.3          14.2               218        5300\n3 Gentoo  Biscoe           50.2          14.3               218        5700\n4 Gentoo  Biscoe           42.9          13.1               215        5000\n5 Gentoo  Biscoe           46.1          13.2               211        4500\n6 Gentoo  Biscoe           44.9          13.3               213        5100\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-note\n#### The full set of `slice_` functions\n\n- `slice_head(n = 1)` takes the first row.\n- `slice_tail(n = 1)` takes the last row\n- `slice_min(x, n = 1)` takes the row with the smallest value in column `x`.\n- `slice_max(x, n = 1)` takes the row with the largest value in column `x`.\n- `slice_sample(n = 1)` takes one random row.\n- `slice(15)` takes the 15th row.\n:::\n\n<br>\n\n::: exercise\n\n## Exercises III\n\n### No ties, please\n\nAbove, when we first used `slice_min()`, we got multiple rows for some groups.\nCheck out the help for this function (`?slice_min`) and get it to print only one row per group,\neven in the case of ties.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\nThe `with_ties` argument controls this. The default is `TRUE` (do include ties),\nso we want to set it to `FALSE` (don't include ties):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  slice_min(body_mass_g, by = species, with_ties = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 3 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Adelie    Biscoe           36.5          16.6               181        2850\n2 Gentoo    Biscoe           42.7          13.7               208        3950\n3 Chinstrap Dream            46.9          16.6               192        2700\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Random penguins\n\nUse `slice_sample()` to get 5 random penguins for each combination of `year` and\n`island`.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_noNA |>\n  slice_sample(n = 5, by = c(year, island))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` styled-output\n# A tibble: 45 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           34.6          21.1               198        4400\n 2 Adelie  Torgersen           36.7          19.3               193        3450\n 3 Adelie  Torgersen           39.2          19.6               195        4675\n 4 Adelie  Torgersen           39.1          18.7               181        3750\n 5 Adelie  Torgersen           40.3          18                 195        3250\n 6 Gentoo  Biscoe              40.9          13.7               214        4650\n 7 Gentoo  Biscoe              50            15.3               220        5550\n 8 Gentoo  Biscoe              46.7          15.3               219        5200\n 9 Gentoo  Biscoe              47.6          14.5               215        5400\n10 Gentoo  Biscoe              42.9          13.1               215        5000\n# ℹ 35 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n</details>\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}