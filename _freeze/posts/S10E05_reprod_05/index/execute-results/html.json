{
  "hash": "5edd38451880531683fce45388251580",
  "result": {
    "markdown": "---\ntitle: \"Reproducibility recommendations: Code styling\"\nsubtitle: \"Recommendations on code styling to improve the reproducibility of your research\"\npagetitle: \"Reproducibility 5\"\nauthor: \"Horacio Lopez-Nicora\"\ndate: \"2025-10-06\"\ncategories: [reproducibility]\ntitle-block-banner: false\nimage: img/lintr_logo.png\nnumber-depth: 3\nexecute: \n  eval: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n<br>\n\n## Introduction\n\n> Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread. \\[[R for Data Science (2e)](https://r4ds.hadley.nz)\\]\n\nWelcome to this Code Club OSU session on Code Styling in R. Whether you're just starting out with R or looking to improve the readability and consistency of your code, this session is designed to give you practical, beginner-friendly guidance on writing clean and professional R code. Code styling is more than just aesthetics, it’s about making your code easier to understand, debug, and share with others. In collaborative environments like research labs, classrooms, or open-source projects, consistent style helps everyone stay on the same page.\n\nToday, we’ll explore key principles from the tidyverse style guide and the R for Data Science workflow/style chapter, and apply them using real datasets like [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/articles/intro.html).\n\n![](https://allisonhorst.github.io/palmerpenguins/reference/figures/lter_penguins.png){fig-align=\"center\" width=\"435\"}\n\nBy the end of this session, you’ll be able to recognize good style, apply it to your own code, and understand why it matters. Let’s dive in!\n\nBefore we start, let’s quickly build on what we covered last session about organizing our code. Now, go ahead and load the **tidyverse** and **janitor** packages. If you haven’t installed them yet, install them first.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# LOAD PACKAGES\n\n# install.packages(\"janitor\")\nlibrary(janitor) # To fix column names with clean_names() (version 2.2.1)\n\n#install.packages(\"janitor\")\nlibrary(tidyverse) # Data summarizing, plotting, and writing (version 2.0.0)\n```\n:::\n\n\n## Why Code Style Matters\n\nWhen writing code, especially in a collaborative or academic setting, style is not just a matter of personal preference, it’s a matter of clarity and professionalism.\n\n**Well-styled code** is easier to *read*, *debug*, and *maintain*. It helps others understand your logic without needing extensive explanations. **Inconsistent** or **messy code** can *slow down* projects, introduce *errors*, and make collaboration *frustrating*. By following a consistent style guide, like the [tidyverse style guide](https://style.tidyverse.org), you ensure that your code communicates clearly and efficiently. Today, we’ll learn how to make our R code clean, readable, and consistent; skills that will serve you well in research, coursework, and data science projects.\n\n## **Naming Conventions:** Human-Readable & Machine-Readable\n\nOne of the first steps toward clean code is choosing good names for your variables and functions. In R, we recommend using **snake_case**—lowercase letters with underscores separating words. For example, `penguin_summary` is much clearer than something like `df1` or `temp`.\n\nGood names describe what the object contains or does, making your code self-documenting. Avoid abbreviations unless they’re widely understood, and don’t be afraid to use longer names if they improve clarity. Think of naming as labeling your thoughts, make it easy for someone else (or future you) to understand what each part of your code is doing.\n\n``` r\n# Messy Example\ndf1 <- penguins\ntemp <- group_by(df1, species)\nresult <- summarise(temp, mean(body_mass, na.rm = TRUE))\n\n# Styled Example\npenguin_summary <- penguins |> \n  group_by(species) |> \n  summarise(avg_mass = mean(body_mass, na.rm = TRUE))\n\n# Style notes:\n# - Use descriptive names: 'penguin_summary' instead of 'df1' or 'temp'\n# - Use snake_case consistently\n# - Avoid vague or temporary names\n```\n\nGood names serve **two audiences**:\n\n1.  **Humans**: other programmers (or your future self) need to understand what the code does quickly.\n\n2.  **Machines**: R and other tools need names that are valid, unambiguous, and free of spaces or special characters.\n\n### Human-Readable\n\n-   Names should **clearly describe** the content or purpose of the object.\n\n-   Avoid abbreviations that aren’t widely understood.\n\n``` r\n# We immediately know what it represents:\navg_flipper_length <- mean(penguins$flipper_len, na.rm = TRUE)\n\n# Avoid vague or cryptic names:\nx <- mean(penguins$flipper_len)\n```\n\n### Machine-Readable\n\n-   Avoid spaces, special characters, or punctuation in names.\n\n-   Column names imported from CSVs are often **not machine-friendly**:\n\n``` r\n#\"Flipper Length (mm)\" → contains spaces and parentheses \n\n# Use snake_case and letters/numbers/underscores only:\nflipper_length_mm\n```\n\n### **Balancing Both**\n\n| Aspect | Recommendation |\n|------------------------------------|------------------------------------|\n| Human readability | Use descriptive, clear names, readable words, meaningful abbreviations |\n| Machine readability | Use snake_case, no spaces/special characters, consistent casing |\n| Example | `avg_bill_length` ✅ vs `Avg.Bill.Length` ❌ |\n\nTools like **`janitor::clean_names()`** make column names both human- and machine-readable:\n\n[![Artwork by \\@allison_horst](img/janitor_clean_names.png){fig-align=\"center\"}](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html)\n\nUsing `janitor::clean_names()` at the start of a data analysis project is a simple step that prevents a lot of frustration later. Real-world datasets often come with inconsistent, messy column names—things like spaces, capital letters, punctuation, or mixed naming styles. These names can slow you down when writing code, force you to use backticks, and break the flow of tidyverse functions.\n\nBy cleaning names immediately, you convert everything to consistent, machine-friendly, **snake_case** column names that are easy to type, reference, and style. It also supports cleaner pipelines, improves readability, and aligns with best practices for reproducible and collaborative code.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# MESSY Code\n\n# Examine dataset\npenguins_raw |> glimpse()\n\n# Select variables of interes\npenguins_raw |> select(`Body Mass (g)`, Sex, `Date Egg`)\n\n# STYLED Code\n\n# Use janitor::clean_names and select same variables\npenguins_raw |> clean_names() |> glimpse()\npenguins_raw |> clean_names() |> select(body_mass_g, sex, date_egg)\n```\n:::\n\n\n## **Pipes and Indentation**\n\nThe pipe operator (`|>`) is one of the most powerful tools in the tidyverse. It allows you to write code that reads like a sequence of actions: take this data, do this, then do that. Each step in a pipeline should be indented on a new line, making the flow of logic easy to follow. For example, when summarizing data, you might start with `penguins |>`, then indent `group_by(species)`, and follow with `summarise(...)`. This structure helps you and others quickly scan and understand the transformation. Indentation is not just about aesthetics—it’s about making your code readable and maintainable.\n\nLets' look at some examples:\n\n#### **Example 1: Filtering and Summarizing**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Cramped, no indentation, unclear naming\nx <- penguins |> filter(species==\"Adelie\") |> group_by(island) |> summarise(avg=mean(body_mass,na.rm=TRUE))\n\n# ✅ GOOD STYLE: Clear naming, spacing, indentation, and comments\nadelie_summary <- penguins |> \n  filter(species == \"Adelie\") |> # Filter to Adelie penguins\n  group_by(island) |>            # Group by island\n  summarise(avg_mass = mean(body_mass, na.rm = TRUE))  # Calculate average body mass\n```\n:::\n\n\n#### **Example 2: Mutate and Arrange**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Semicolon chaining, inconsistent naming\npenguins2<-mutate(penguins,bmi=body_mass/bill_len);arrange(penguins2,bmi)\n\n# ✅ GOOD STYLE: Pipe used throughout, clear naming, spacing, and indentation\npenguins_bmi <- penguins |> \n  mutate(bmi = body_mass / bill_len) |> # Create BMI variable\n  arrange(bmi)                                  # Sort by BMI\n```\n:::\n\n\n#### **Example 3: Summarise Misalignment**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Misaligned summarise arguments\npenguins |> \n  group_by(species) |> \n  summarise(avg_mass = mean(body_mass, na.rm = TRUE), \n  count = n())\n\n# ✅ GOOD STYLE: Each summary on its own line, aligned\npenguins |> \n  group_by(species) |> \n  summarise(\n    avg_mass = mean(body_mass, na.rm = TRUE),\n    count = n()\n  )\n```\n:::\n\n\n#### **Example 4: Broken Pipe Chain**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Pipe chain is broken\npenguins |> \n  group_by(species)\nsummarise(avg_mass = mean(body_mass, na.rm = TRUE))\n\n# ✅ GOOD STYLE: Pipe chain is continuous\npenguins |> \n  group_by(species) |> \n  summarise(avg_mass = mean(body_mass, na.rm = TRUE))\n```\n:::\n\n\n## **Spacing and Alignment**\n\nConsistent spacing around operators and arguments improves readability. For example, write `x = 5` instead of `x=5`, and align similar lines when possible. This makes patterns in your code easier to spot and reduces cognitive load. When writing multiple lines of similar code, aligning them vertically can help highlight differences and similarities. **Think of spacing as visual punctuation**, it guides the reader’s eye and helps them parse your code more easily. Avoid cramming everything into one line; give your code room to breathe.\n\n#### Example 1: Assignment and Function Calls\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: No spacing, cramped code\npenguins_summary<-penguins|>group_by(species)|>summarise(avg=mean(body_mass,na.rm=TRUE))\n\n# ✅ GOOD STYLE: Proper spacing and alignment\npenguins_summary <- penguins |> \n  group_by(species) |> \n  summarise(avg_mass = mean(body_mass, na.rm = TRUE))\n\n# Style notes:\n# - Use spaces around assignment (<-), pipes (|>), and function arguments (=)\n# - Align each step of the pipeline on a new line\n# - Use descriptive variable and column names\n```\n:::\n\n\n#### Example 2: Multiple Arguments in `summarise()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Arguments crammed together\npenguins |> group_by(species) |> summarise(avg=mean(body_mass,na.rm=TRUE),count=n())\n\n# ✅ GOOD STYLE: Each argument on its own line, aligned\npenguins |> \n  group_by(species) |> \n  summarise(\n    avg_mass = mean(body_mass, na.rm = TRUE),\n    count = n()\n  )\n\n# Style notes:\n# - Each summary metric is on its own line\n# - Arguments are aligned for readability\n```\n:::\n\n\n## **Inline Comments**\n\nComments are your opportunity to explain ***why*** your code does what it does. While code should be self-explanatory through good naming and structure, comments provide context that might not be obvious. For example, `# remove NA values` tells the reader why `na.rm = TRUE` is used. Avoid redundant comments like `# load data` when the code already says `library(palmerpenguins)`. Instead, focus on explaining decisions, assumptions, or non-obvious steps. Comments should be brief, relevant, and placed directly above or beside the code they refer to.\n\n#### Example 1: No Comments or Unhelpful Comments\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: No explanation or vague comment\npenguins |> \n  filter(species == \"Chinstrap\") |> \n  summarise(mean(flipper_len, na.rm = TRUE))  # summary\n\n# ✅ GOOD STYLE: Clear, helpful inline comments\npenguins |> \n  filter(species == \"Chinstrap\") |>                 # Focus on Chinstrap penguins\n  summarise(avg_flipper = mean(flipper_len, na.rm = TRUE))  # Calculate average flipper length\n\n# Style notes:\n# - Comments explain *why* or *what* is being done\n# - Avoid stating the obvious or repeating the code\n```\n:::\n\n\n#### Example 2: Misplaced or Redundant Comments\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Redundant and misplaced comments\n# This is a filter\npenguins |> \n  filter(species == \"Gentoo\") |> \n  # This is a summarise\n  summarise(mean(body_mass, na.rm = TRUE))\n\n# ✅ GOOD STYLE: Concise and well-placed comments\npenguins |> \n  filter(species == \"Gentoo\") |>                    # Filter for Gentoo penguins\n  summarise(avg_mass = mean(body_mass, na.rm = TRUE))  # Calculate average body mass\n```\n:::\n\n\n## **Plotting with Style**\n\nVisualizations are a key part of data analysis, and styling your plots is just as important as styling your code. Use clear labels for axes and titles, choose readable color schemes, and **structure your `ggplot` code with indentation for each layer**. For example, start with `ggplot(...)`, then indent `geom_boxplot(...)`, `labs(...)`, and `theme_minimal()`. This makes it easy to see how the plot is constructed. Avoid cluttered plots, simplicity and clarity should guide your design choices. Well-styled plots communicate insights effectively and make your work look polished.\n\n#### Example 1: Cramped and Unlabeled Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: No labels, no spacing\nggplot(penguins, aes(species, body_mass)) + geom_boxplot()\n\n# ✅ GOOD STYLE: Clear labels, spacing, and structure\nggplot(penguins, aes(x = species, y = body_mass)) +\n  geom_boxplot(fill = \"lightblue\") +\n  labs(\n    title = \"Body Mass by Species\",\n    x = \"Species\",\n    y = \"Body Mass (g)\"\n  ) +\n  theme_minimal()\n\n# Style notes:\n# - Use `labs()` to label axes and title\n# - Indent each layer of the plot\n# - Use readable color names and themes\n```\n:::\n\n\n#### Example 2: Overly Complex One-Liner\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# ❌ BAD STYLE: Everything in one line, hard to read\nggplot(penguins,aes(x=species,y=flipper_len,fill=sex))+geom_violin()+theme_minimal()+labs(title=\"Flipper Length\",x=\"Species\",y=\"Length\")\n\n# ✅ GOOD STYLE: Structured and readable\nggplot(penguins, aes(x = species, y = flipper_len, fill = sex)) +\n  geom_violin() +\n  labs(\n    title = \"Flipper Length by Species and Sex\",\n    x = \"Species\",\n    y = \"Flipper Length (mm)\",\n    fill = \"Sex\"\n  ) +\n  theme_minimal()\n\n# Style notes:\n# - Each ggplot layer is on its own line\n# - Labels are clear and informative\n# - Code is easy to scan and modify\n```\n:::\n\n\n## Interactive Code Styling with `lintr` and `styler`\n\nAs you begin writing more R code, it’s helpful to use tools that automatically check and improve your code style. Two popular packages for this are `lintr` and `styler`. These tools help you write cleaner code by identifying style violations (`lintr`) and automatically reformatting code (`styler`) to follow tidyverse conventions.\n\nThese tools are especially useful in teaching, collaborative projects, and when preparing code for publication or sharing. Let’s look at how each works with examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# INSTALL PACKAGES\ninstall.packages(\"lintr\")\ninstall.packages(\"styler\")\n\n# LOAD PACKAGES\nlibrary(lintr)\nlibrary(styler)\n```\n:::\n\n\n### Using `lintr` to Check Code Style\n\n**`lintr`** is like a spell-checker for your code. It scans your scripts and flags issues such as inconsistent spacing, bad naming, or improper indentation.\n\n#### Example 1: Lint a messy code snippet\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstyler::style_text(\"x <- 1+1\")\n\nlint(text = \"penguins |>filter(species=='Adelie')|>summarise(mean(body_mass,na.rm=TRUE))\")\n\n# Output (example):\n# - Missing spaces around operators\n# - Pipe not followed by a space\n```\n:::\n\n\n#### Example 2: Lint a messy code for data viz\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlint(text = \"ggplot(penguins,aes(species,body_mass))+geom_boxplot()\")\n\n# Output (example):\n# - Missing spaces around operators\n# - Layers not followed by a space\n```\n:::\n\n\n### Using `styler` to Check Code Style\n\n**`styler`** is like an auto-correct tool, it reformats your code to match a consistent style guide, such as the tidyverse style.\n\n#### Example 1: Style a messy pipe chain\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstyle_text(\"penguins |>filter(species=='Adelie')|>summarise(mean(body_mass,na.rm=TRUE))\")\n\n# Output:\n# penguins |> \n#   filter(species == \"Adelie\") |> \n```\n:::\n\n\n#### Example 2: Style a cluttered ggplot call\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstyle_text(\"penguins|>ggplot(aes(species,body_mass))+geom_boxplot()\")\n\n# Output:\n# penguins |> ggplot(aes(species, body_mass_g)) +\n#   geom_boxplot()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}