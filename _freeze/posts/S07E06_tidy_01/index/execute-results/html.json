{
  "hash": "41f87676334a2026a133b50fb9e89f29",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Basics - 06 Introduction to the `tidyverse`\"\nauthor:\n  - \"Jessica Cooperstone\"\ndate: \"2024-02-16\"\ncategories: [r-basics, tidyverse]\ntitle-block-banner: false\nimage: img/tidyverse-package-workflow.png\n---\n\n::: {.cell}\n\n:::\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Introduction\n\nWe are going to introduce a new package and series of functions today that are designed for data science.\n\n## What is the `tidyverse`?\n\n[\"The tidyverse\"](https://www.tidyverse.org/) is a collection of packages called that are designed for data science. You can certainly use R without using the tidyverse, but it has many packages that I think will make your life a lot easier. We will be using mostly tidyverse functions in this class, with some base R syntax scattered throughout.\n\n![Figure from [teachdatascience.com](https://teachdatascience.com/tidyverse/)](img/tidyverse-package-workflow.png)\n\nThe \"core tidyverse\" contains the 8 packages below:\n\n-   [`dplyr`](https://dplyr.tidyverse.org/): for data manipulation\n-   [`ggplot2`](https://ggplot2.tidyverse.org/): a \"grammar of graphics\" for creating beautiful plots\n-   [`readr`](https://readr.tidyverse.org/): for reading in rectangular data (i.e., Excel-style formatting)\n-   [`tibble`](https://tibble.tidyverse.org/): using tibbles as modern/better dataframes\n-   [`stringr`](https://stringr.tidyverse.org/): handling strings (i.e., text or stuff in quotes)\n-   [`forcats`](https://forcats.tidyverse.org/): for handling categorical variables (i.e., factors) (meow!)\n-   [`tidyr`](https://tidyr.tidyverse.org/): to make \"tidy data\"\n-   [`purrr`](https://purrr.tidyverse.org/): for enhancing functional programming (also meow!)\n\nWe will be using many of these other packages in Code Club and we will talk about them as we go. There are more tidyverse packages outside of these core eight, and we will talk about some of them another time.\n\n> **tl;dr** Tidyverse has a lot of packages that make data analysis easier. None of them are required, but I think you'll find many tidyverse approaches easier and more intuitive than using base R.\n\n## Installing new packages\n\nSo far, we have used only functions and data that exist within \"base R\" - or the portion of R that comes with the default install. R is an open source language, meaning people all around the world can develop tools that can be used within R. These tools are always evolving, and there are way too many of them for them to all come pre-downloaded.\n\nThese tools mostly live within something called a \"package\". You can think about a package as a unit of code that can be shared and reused. These packages can include both functions and data. A person (or team) can create a package, make that available for download, and then anyone can use it.\n\nTo install packages in R that are on the [Comprehensive R Archive Network (CRAN)](https://cran.r-project.org/), you can use the function `install.packages()`. There are packages that are not on CRAN but we are not going to talk about them today. Be sure that you provide the name of your packages as a string, and put it in quotes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\n## Loading packages\n\nOnce you have downloaded a package, you now have it, you can think about it as a book that you now own. When you want to read the book, you don't need to go buy it again, you need to simply take it off your shelf and open it. Using the function [`library()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/library) takes your package from where it is stored on the \"shelf\" in your computer, and opens it. I hope this is an ok metaphor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\nIt's a good habit to not ignore warnings/messages that R gives you.\n\n::: {.callout-warning title=\"What does this warning mean?\"}\n:::\n\n> We only need to install packages once. But, every time we want to use them, we need to \"load\" them, and can do this using the function `library()`.\n\n## Practice\n\n::: {.callout-note title=\"Please install the tidyverse and then load it.\" collapse=\"true\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# it doesn't matter here if you put tidyverse in quotes or not\n# without quotes will work since you can think about it as an object\n# that already exists (and not just a string of characters)\nlibrary(tidyverse) # works\nlibrary(\"tidyverse\") # also works\n```\n:::\n\n\n:::\n\n## Data for today\n\nIn addition to having functions, packages also can contain data. Within the `tidyverse` package, there is a bunch of embedded data we can use to play around with.\n\nIf you type the function `data()` and then place your cursor between the parentheses and hit tab, you will see what pre-loaded data in R you have access to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata()\n```\n:::\n\n\n![](img/data.png)\n\nToday we are going to use a dataset called `diamonds` that is embedded within the package `ggplot` (which we have since it gets automatically installed when we load the `tidyverse`).\n\nLet's learn about `diamonds` using some of the functions [we learned already](https://osu-codeclub.github.io/posts/basics_04/#what-is-a-data-frame).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n```\n\n\n:::\n:::\n\n\nTidyverse has a version of `str()` called [`glimpse()`](https://dplyr.tidyverse.org/reference/glimpse.html) which does a similar thing but tries to show you more data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 53,940\nColumns: 10\n$ carat   <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.…\n$ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver…\n$ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,…\n$ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, …\n$ depth   <dbl> 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64…\n$ table   <dbl> 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58…\n$ price   <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34…\n$ x       <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.…\n$ y       <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.…\n$ z       <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.…\n```\n\n\n:::\n:::\n\n\n> Note that we do **not** see diamonds as an object in our enrivonrment, even though clearly it's there.\n\n## The pipe `|>` or `%>%`\n\n[The pipe](https://r4ds.had.co.nz/pipes.html) `|>` or `%>%` is a tool that allows you to take the output of one function, and send it to the next function.\n\nYou can read the pipe as \"and then\" - here is a theoretical example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntake_this_data |>\n  then_this_function() |>\n  then_another_function() |> \n  finally_a_last_function()\n```\n:::\n\n\nThe easiest way to see how the pipe works is with an example. We are going to go over some examples in a minute.\n\nSome reasons I like the pipe:\n\n-   its easier to read (and doesn't have a lot of nested parentheses)\n-   it doesn't require you to create lots of interim objects which you won't use again\n-   its easy to troubleshoot\n\n> The keyboard shortcut for `|>` is `Ctrl/Cmd` + `Shift` + `M`\n\nWe can change our R options so that the newer version of the pipe `|>` is used over the older one `%>%` when we use the keyboard shortcut. I try and remember to use the new one but it doesn't always happen, so do be familiar with both.\n\nYou can go to `Tools` > `Global Options` > `Code` and make sure the tick mark is checked next to \"Use the native pipe operator, |> (requires R 4.1+).\n\n![](img/pipe-options.png)\n\nOf course you can assign the output of a pipe to something using the assignment operator `<-` and then use it for other things.\n\nSsome functions are not \"pipe friendly\" meaning they will not work using pipes. This is often because the data is not the first argument passed to the function. All tidyverse functions work with piping.\n\n## Selecting columns with `select()`\n\nOften you will want to pick only certain columns in your dataframe, and you can do this with the function [`select()`](https://dplyr.tidyverse.org/reference/select.html). You can pick columns by:\n\n-   their names\n-   their position (i.e., index)\n-   characteristics of that column\n\nIf we want to know how the arguments to `select()` work, we can access the documentation material about the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?select()\n```\n:::\n\n\nThe arguments to `select()` are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(.data, ...)\n```\n:::\n\n\nThis tells us that `select()` accepts a data frame (that's good, `diamonds` is one), and we can pass many other expressions.\n\nLet's select first by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(.data = diamonds, # our df\n       carat, cut, price) # the columns we want to pull\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 53,940 × 3\n   carat cut       price\n   <dbl> <ord>     <int>\n 1  0.23 Ideal       326\n 2  0.21 Premium     326\n 3  0.23 Good        327\n 4  0.29 Premium     334\n 5  0.31 Good        335\n 6  0.24 Very Good   336\n 7  0.24 Very Good   336\n 8  0.26 Very Good   337\n 9  0.22 Fair        337\n10  0.23 Very Good   338\n# ℹ 53,930 more rows\n```\n\n\n:::\n:::\n\n\nOr, we could more simply use the pipe `|>` or `%>%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  select(carat, cut, price)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 53,940 × 3\n   carat cut       price\n   <dbl> <ord>     <int>\n 1  0.23 Ideal       326\n 2  0.21 Premium     326\n 3  0.23 Good        327\n 4  0.29 Premium     334\n 5  0.31 Good        335\n 6  0.24 Very Good   336\n 7  0.24 Very Good   336\n 8  0.26 Very Good   337\n 9  0.22 Fair        337\n10  0.23 Very Good   338\n# ℹ 53,930 more rows\n```\n\n\n:::\n:::\n\n\nWe can read this as, take the dataset diamonds, then select the columns carat, cut, and price. That was pretty easy to read!\n\nNote that when you use the pipe, the potential column names will auto-fill for you after you type 3 letters. You should use this option as it will help prevent misspellings. You can also hit `tab` to scroll through all the potential objects to select.\n\nWe can also select by index. In general I would recommend against this because its really hard to remember which column indices are which variables today, nevermind returning back to old code 1 year from now. Still I will show you how.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  select(c(1, 2, 7)) # you could also use the colon syntax if your columns are sequential\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 53,940 × 3\n   carat cut       price\n   <dbl> <ord>     <int>\n 1  0.23 Ideal       326\n 2  0.21 Premium     326\n 3  0.23 Good        327\n 4  0.29 Premium     334\n 5  0.31 Good        335\n 6  0.24 Very Good   336\n 7  0.24 Very Good   336\n 8  0.26 Very Good   337\n 9  0.22 Fair        337\n10  0.23 Very Good   338\n# ℹ 53,930 more rows\n```\n\n\n:::\n:::\n\n\nYou can also select using selection helpers like:\n\n-   [`everything()`](https://tidyselect.r-lib.org/reference/everything.html): picks all variables\n-   [`starts_with()`](https://tidyselect.r-lib.org/reference/starts_with.html): starts with some prefix\n-   [`contains()`](https://tidyselect.r-lib.org/reference/starts_with.html): contains a specific string\n-   [`where()`](https://tidyselect.r-lib.org/reference/where.html): selects columns where the statement given in the argument is TRUE\n\nHere is an example of using `where()` to select only the columns that are numeric. The function `where()` asks whether the following function is TRUE or FALSE, and keeps only the occurences that evaluate to TRUE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  select(where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 53,940 × 7\n   carat depth table price     x     y     z\n   <dbl> <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23  61.5    55   326  3.95  3.98  2.43\n 2  0.21  59.8    61   326  3.89  3.84  2.31\n 3  0.23  56.9    65   327  4.05  4.07  2.31\n 4  0.29  62.4    58   334  4.2   4.23  2.63\n 5  0.31  63.3    58   335  4.34  4.35  2.75\n 6  0.24  62.8    57   336  3.94  3.96  2.48\n 7  0.24  62.3    57   336  3.95  3.98  2.47\n 8  0.26  61.9    55   337  4.07  4.11  2.53\n 9  0.22  65.1    61   337  3.87  3.78  2.49\n10  0.23  59.4    61   338  4     4.05  2.39\n# ℹ 53,930 more rows\n```\n\n\n:::\n:::\n\n\nYou can find more helpers [here](https://dplyr.tidyverse.org/reference/select.html).\n\nUsing `select()` will also set the order of your columns. More about this in practice.\n\n## Choosing observations with `filter()`\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Figure from [Allison Horst](https://github.com/allisonhorst/stats-illustrations)](img/filter.png){fig-align='center' fig-alt='Cartoon showing three fuzzy monsters either selecting or crossing out rows of a data table. If the type of animal in the table is “otter” and the site is “bay”, a monster is drawing a purple rectangle around the row. If those conditions are not met, another monster is putting a line through the column indicating it will be excluded. Stylized text reads “dplyr::filter() - keep rows that satisfy your conditions.” Learn more about dplyr::filter.' width=70%}\n:::\n:::\n\n\nSometimes you want to select observations (rows) based on values. To do this you use [`filter()`](https://dplyr.tidyverse.org/reference/filter.html). Try not to confuse this with `select()`.\n\n::: {.callout-note title=\"`select()` picks columns, while `filter()` picks rows.\"} \n:::\n\nThe function `filter()` will keep only observations that meet your filtering criteria.\n\nLet's say we want to only keep the diamonds that are bigger than 3 carats.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# without the pipe\n# i find this harder to read\nfilter(.data = diamonds, \n       carat > 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  3.01 Premium I     I1       62.7    58  8040  9.1   8.97  5.67\n 2  3.11 Fair    J     I1       65.9    57  9823  9.15  9.02  5.98\n 3  3.01 Premium F     I1       62.2    56  9925  9.24  9.13  5.73\n 4  3.05 Premium E     I1       60.9    58 10453  9.26  9.25  5.66\n 5  3.02 Fair    I     I1       65.2    56 10577  9.11  9.02  5.91\n 6  3.01 Fair    H     I1       56.1    62 10761  9.54  9.38  5.31\n 7  3.65 Fair    H     I1       67.1    53 11668  9.53  9.48  6.38\n 8  3.24 Premium H     I1       62.1    58 12300  9.44  9.4   5.85\n 9  3.22 Ideal   I     I1       62.6    55 12545  9.49  9.42  5.92\n10  3.5  Ideal   H     I1       62.8    57 12587  9.65  9.59  6.03\n# ℹ 22 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# the pipe/my preferred way\ndiamonds |> \n  filter(carat > 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  3.01 Premium I     I1       62.7    58  8040  9.1   8.97  5.67\n 2  3.11 Fair    J     I1       65.9    57  9823  9.15  9.02  5.98\n 3  3.01 Premium F     I1       62.2    56  9925  9.24  9.13  5.73\n 4  3.05 Premium E     I1       60.9    58 10453  9.26  9.25  5.66\n 5  3.02 Fair    I     I1       65.2    56 10577  9.11  9.02  5.91\n 6  3.01 Fair    H     I1       56.1    62 10761  9.54  9.38  5.31\n 7  3.65 Fair    H     I1       67.1    53 11668  9.53  9.48  6.38\n 8  3.24 Premium H     I1       62.1    58 12300  9.44  9.4   5.85\n 9  3.22 Ideal   I     I1       62.6    55 12545  9.49  9.42  5.92\n10  3.5  Ideal   H     I1       62.8    57 12587  9.65  9.59  6.03\n# ℹ 22 more rows\n```\n\n\n:::\n:::\n\n\nHere I made use of the greater than `>` sign, and there are other operators you could also use to help you filter.\n\n-   `==`: equal to (I usually read this as exactly equal to, and is different than using an equal sign in an equation)\n-   `<`, `>`: less than or greater than\n-   `<=`, `>=`: less than or equal to, great than or equal to\n-   `&`: and\n-   `|`: or\n-   `!`: not equal\n-   `is.na`: is NA\n\nYou can also layer your filtering. This can include in both an AND or OR fashion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# include diamonds that are bigger than 3 carats and a Premium cut\ndiamonds |> \n  filter(carat > 3 & cut == \"Premium\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  3.01 Premium I     I1       62.7    58  8040  9.1   8.97  5.67\n 2  3.01 Premium F     I1       62.2    56  9925  9.24  9.13  5.73\n 3  3.05 Premium E     I1       60.9    58 10453  9.26  9.25  5.66\n 4  3.24 Premium H     I1       62.1    58 12300  9.44  9.4   5.85\n 5  3.01 Premium G     SI2      59.8    58 14220  9.44  9.37  5.62\n 6  4.01 Premium I     I1       61      61 15223 10.1  10.1   6.17\n 7  4.01 Premium J     I1       62.5    62 15223 10.0   9.94  6.24\n 8  3.67 Premium I     I1       62.4    56 16193  9.86  9.81  6.13\n 9  3.01 Premium I     SI2      60.2    59 18242  9.36  9.31  5.62\n10  3.04 Premium I     SI2      59.3    60 18559  9.51  9.46  5.62\n11  3.51 Premium J     VS2      62.5    59 18701  9.66  9.63  6.03\n12  3.01 Premium J     SI2      60.7    59 18710  9.35  9.22  5.64\n13  3.01 Premium J     SI2      59.7    58 18710  9.41  9.32  5.59\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# include diamonds that are bigger than 3 carats OR a Premium cut\n# \"|\" (above the return key) is the symbol for \"or\"\ndiamonds |> \n  filter(carat > 3 | cut == \"Premium\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13,810 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.21 Premium E     SI1      59.8    61   326  3.89  3.84  2.31\n 2  0.29 Premium I     VS2      62.4    58   334  4.2   4.23  2.63\n 3  0.22 Premium F     SI1      60.4    61   342  3.88  3.84  2.33\n 4  0.2  Premium E     SI2      60.2    62   345  3.79  3.75  2.27\n 5  0.32 Premium E     I1       60.9    58   345  4.38  4.42  2.68\n 6  0.24 Premium I     VS1      62.5    57   355  3.97  3.94  2.47\n 7  0.29 Premium F     SI1      62.4    58   403  4.24  4.26  2.65\n 8  0.22 Premium E     VS2      61.6    58   404  3.93  3.89  2.41\n 9  0.22 Premium D     VS2      59.3    62   404  3.91  3.88  2.31\n10  0.3  Premium J     SI2      59.3    61   405  4.43  4.38  2.61\n# ℹ 13,800 more rows\n```\n\n\n:::\n:::\n\n\nYou can play around with combining these different operators to see what happens.\n\n## Practice\n\n::: {.callout-note title=\"Create a new dataframe called `small_diamonds` that includes only the diamonds that are less than 0.5 carats. How many diamonds does this include?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_diamonds <- diamonds |>\n  filter(carat < 0.5)\n\nnrow(small_diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17674\n```\n\n\n:::\n:::\n\n:::\n\n::: {.callout-note title=\"Subset diamonds into a new df (`diamonds_subset`) so that it only includes diamonds less than $10,000, and only information for carat, cut, price, and color, in that specific order.\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_subset <- diamonds |>\n  filter(price < 10000) |>\n  select(carat, cut, price, color) # select both picks and orders!\n```\n:::\n\n:::\n\n::: {.callout-note title=\"What is the mean and standard deviation of carat of the diamonds that passed your critieria in `diamonds_subset`?\" collapse=\"true\"}\n\nUsing the `$`\n\n::: {.cell}\n\n```{.r .cell-code}\n# mean\nmean(diamonds_subset$carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6968262\n```\n\n\n:::\n\n```{.r .cell-code}\n# sd\nsd(diamonds_subset$carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3574645\n```\n\n\n:::\n:::\n\n\nUsing the pipe\n\n::: {.cell}\n\n```{.r .cell-code}\n# mean another way\ndiamonds_subset |>\n  pull(carat) |> # this is necessary because mean requires a vector!\n  mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6968262\n```\n\n\n:::\n\n```{.r .cell-code}\n# or you could go full pipe!\ndiamonds |>\n  filter(price < 10000) |>\n  pull(carat) |>\n  mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6968262\n```\n\n\n:::\n\n```{.r .cell-code}\n# sd another way\ndiamonds_subset |>\n  pull(carat) |> # this is necessary because mean requires a vector!\n  sd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3574645\n```\n\n\n:::\n\n```{.r .cell-code}\n# or you could go full pipe!\ndiamonds |>\n  filter(price < 10000) |>\n  pull(carat) |>\n  sd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3574645\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"How many diamonds in this dataset are both Ideal cut, less than $10,000, and bigger than 1.5 carats??\" collapse=\"true\"}\nWhen you are trying to filter using \"and\" and have more than 2 items, use a comma in between them.\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  filter(price < 10000, cut == \"Ideal\", carat > 1.5) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 327\n```\n\n\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}