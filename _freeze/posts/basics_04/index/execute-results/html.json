{
  "hash": "0f8f5437e84eed7be9111e806e5f8da9",
  "result": {
    "markdown": "---\ntitle: \"R Basics - 04 Vectorized Operations and Data Frame Introduction\"\nauthor:\n  - \"Jessica Cooperstone\"\ndate: \"2024-02-02\"\ncategories: [r-basics]\ntitle-block-banner: false\nimage: img/vector-vs-df.png\n---\n\n::: {.cell}\n\n:::\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Introduction\n\nWe are going to continue our discussion about vectors that Horacio started this week and talk about vectorized operations. It's fine if you don't know what this means, you will by the end of today's session. We are also going to introduce the idea of a data frame.\n\n## What are vectorized operations?\n\nI think its easier to \"see\" an example of a vectorized operation, and then we can explain what is happening under the hood.\n\nLet's create a vector of high temperatures for the weather in Columbus OH from the last 7 days. I took this data from January 19 to 25, 2024.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_F <- c(26, 21, 24, 32, 33, 41, 51)\n```\n:::\n\n\nWe can call our vector to see what it contains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_F\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26 21 24 32 33 41 51\n```\n:::\n:::\n\n\nA reminder that:\n\n$$\n°F = 1.8 * °C + 32\n$$\n\nWith some light rearrangement, we can write the code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_C <- (temps_F - 32)/1.8\n\ntemps_C\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3.3333333 -6.1111111 -4.4444444  0.0000000  0.5555556  5.0000000 10.5555556\n```\n:::\n:::\n\n\nHere, we simply use the vector `temps_F` as we would any other simpler mathematical operation, and we convert each element or number in our our entire vector using the formula we provide. As a result, we can convert our vector from Fahrenheit to Celsius.\n\nIt is worth mentioning that this is *unique in R* - many other programming languages would require a for loop or similar to do this operation, but because R is a vectorized language, this works easily and simply.\n\nHere is another example. Imagine you have a vector of values and you want to calculate the log base 2 value for each element.\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- c(20, 36, 42, 53)\n\nlog2 <- log2(raw)\n\nlog2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.321928 5.169925 5.392317 5.727920\n```\n:::\n:::\n\n\n\nThis is an example where we apply a formula transformation to a vector, but we can also use vectorized operations with two vectors.\n\n## Vectors by vector operations\n\nLet's create some vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_1to10 <- c(1:10)\n\nvector_1to5 <- c(1:5)\n\nvector_1to3 <- c(1:3)\n```\n:::\n\n\n::: {.callout-note title=\"What do you think will happen if we try and add `vector_1to10` and `vector_1to5`?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_1to10 + vector_1to5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  4  6  8 10  7  9 11 13 15\n```\n:::\n:::\n\n\nWe see that `vector_1to5` gets recycled, meaning once the 5 elements in the vector have been used, the addition starts back from the beginning again. If we want to be explicit:\n\n* Element 1 of `vector_1to10` gets added to element 1 of `vector_1to5`\n* Element 2 of `vector_1to10` gets added to element 2 of `vector_1to5`\n* Element 3 of `vector_1to10` gets added to element 3 of `vector_1to5`\n* Element 4 of `vector_1to10` gets added to element 4 of `vector_1to5`\n* Element 5 of `vector_1to10` gets added to element 5 of `vector_1to5`.\n* Element 6 of `vector_1to10` gets added to **element 1** of `vector_1to5`\n\nand so on...\n\n**This happens without R explicitly telling you this is happening. We do not get a warning.**\n\n:::\n\n::: {.callout-note title=\"What do you think will happen if we try and add `vector_1to10` and `vector_1to3`?\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_1to10 + vector_1to3\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in vector_1to10 + vector_1to3: longer object length is not a multiple\nof shorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  4  6  5  7  9  8 10 12 11\n```\n:::\n:::\n\n\nWe see that `vector_1to3` gets recycled, but now we have a warning. We get this because the vector lengths are not divisible by each other to produce an integer. \n\n:::\n\n\n## Filtering vectors\n\nWe can also write code that allows us to filter our vector based on certain conditions. What if we wanted to know which observations had data where the weather was above freezing? We could use a mathematical operator (in this case, `>`) to find instances when the statement we provide is true.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps_C > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nWhen we run this code, we get a series of answers for each element of the vector, and whether or not the statement we have prompted with (`temps_C > 0`) is true or false.\n\nIf we wanted to see how many observations meet these criteria, we can take advantage of the fact that `TRUE` is coded as 1, and `FALSE` and 0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(temps_C > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nWe know then that there are 3 observations where the temperature is above 0.\n\nIf we want to know which are those observations, we can use the function [`which()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/which) which shows us the indices of the elements in our vector for which our code evaluates to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(temps_C > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 6 7\n```\n:::\n:::\n\n\nThis tells us that the 5th, 6th, and 7th elements in our data have temperatures higher than freezing. But, we don't have those specific days associated with each temperature. We can do that too, by assigning dates using the function [`names()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/names) for our vector. I'll show you how to do that below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new vector that has the dates we want to assign\ndates <- c(\"1/19\", \"1/20\", \"1/21\", \"1/22\", \"1/23\", \"1/24\", \"1/25\")\n\n# we can assign these dates as the \"names\" of our vector temps_C\nnames(temps_C) <- dates\n\n# now our temps have dates associated with them\ntemps_C\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      1/19       1/20       1/21       1/22       1/23       1/24       1/25 \n-3.3333333 -6.1111111 -4.4444444  0.0000000  0.5555556  5.0000000 10.5555556 \n```\n:::\n:::\n\n\nYou might use the sometimes, but more likely you would want to work using a data frame.\n\n## Practice\n\n## What is a data frame?\n\nBelow I am creating a simple data frame, this is a rectangular data object with rows and columns. In reality, you will probably be reading your data in from a `.csv` or `.xlsx` file, but you can also construct a data frame directly in R. We are doing this with the function [`data.frame()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame) which is a part of base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a simple 3 by 4 data frame called small_df\n# columns are a, b, and c\n# values are numbers from 1 to 4, 5 to 8, and 9 to 12\nsmall_df <- data.frame(a = 1:4, \n                       b = 5:8, \n                       c = 9:12)\n```\n:::\n\n\nLet's look at `small_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b  c\n1 1 5  9\n2 2 6 10\n3 3 7 11\n4 4 8 12\n```\n:::\n:::\n\n\nWe can think about a data frame as being composed of a series of vectors (as columns) squished together. In the case above, each column is of the same type, integer or numeric but this doesn't have to be true.\n\n> Vectors all must be of the same object type (i.e., character, numeric, logical). In a data frame, each column can be a different object type. This is very useful.\n\nWe call use some new functions to look more at our data frame.\n\n`View()` will open our data frame like you might be used to looking at a spreadsheet in Excel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(small_df)\n```\n:::\n\n\n`str()` gives us the structure of the object x.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(small_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t4 obs. of  3 variables:\n $ a: int  1 2 3 4\n $ b: int  5 6 7 8\n $ c: int  9 10 11 12\n```\n:::\n:::\n\n\n`dim()` gives us the dimensions of x.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(small_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3\n```\n:::\n:::\n\n\n::: {.callout-important title=\"Note that when referring to a two-dimensional piece of data, R uses the syntax [rows, columns]\"}\n:::\n\nNote, that if you use `dim()` on a vector (which has only one dimension), you will get something unexpected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this doesn't work\ndim(temps_C)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nFor a vector, instead you should use the function `length()` to figure out how many elements are in the vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this does work\nlength(temps_C)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n## Performing operations on a data frame\nNow that we have our `small_df` we can try performing some operations on it.\n\nWhat if you wanted to take the log base 2 for every value in `small_df`? Just like we did for a vector, we can simply use the function `log2()` on `small_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(small_df_log2 <- log2(small_df))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         a        b        c\n1 0.000000 2.321928 3.169925\n2 1.000000 2.584963 3.321928\n3 1.584963 2.807355 3.459432\n4 2.000000 3.000000 3.584963\n```\n:::\n:::\n\n\nRemember, if you assign something to an object, but also want it to print at the same time, just surround the whole thing in parentheses.\n\nWhat if I wanted to take the log base 2 of only column a? There are a few ways I can do that.\n\n### By indexing\n\nI can use the square brackets `[]` to access certain parts of my data frame. Remember for data frames, the syntax is [rows, columns]. Let's try some example where we access by using indices (i.e., the position of the row, column, or the combination) to grab different parts of our data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\n# first row, second column\nsmall_df[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n# all rows, second column\nsmall_df[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 6 7 8\n```\n:::\n\n```{.r .cell-code}\n# third row, all columns\nsmall_df[3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b  c\n3 3 7 11\n```\n:::\n:::\n\n\nIs there any difference as to the types of objects we get when doing these different types of selection? We can use the function `str()` to see what type of R object we have in the different scenarios.\n\n::: {.cell}\n\n```{.r .cell-code}\n# first row, second column\nstr(small_df[1,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int 5\n```\n:::\n\n```{.r .cell-code}\n# all rows, second column\nstr(small_df[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:4] 5 6 7 8\n```\n:::\n\n```{.r .cell-code}\n# third row, all columns\nstr(small_df[3,])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t1 obs. of  3 variables:\n $ a: int 3\n $ b: int 7\n $ c: int 11\n```\n:::\n:::\n\n\nBack to the original idea - how would we take the data only from column \"a\" and log base 2 transform it?\n\n::: {.cell}\n\n```{.r .cell-code}\n# first save our df with a new name\n# this is like doing a \"save as\" for an existing df\nsmall_df_log2_a <- small_df\n\n# log2 transform the first column, and then assign that back to the first column\nsmall_df_log2_a[,1] <- log2(small_df[,1])\n\n# check to see if it worked\nsmall_df_log2_a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         a b  c\n1 0.000000 5  9\n2 1.000000 6 10\n3 1.584963 7 11\n4 2.000000 8 12\n```\n:::\n:::\n\n\n\n### By name\nWe can also index by providing column names - this is a nice approach since when going back to read code, a column name is often more informative than a column index/number. Note that in this case the column name `a` is in quotes since it is a character string.\n\n::: {.cell}\n\n```{.r .cell-code}\n# all rows, the column \"a\"\nsmall_df[,\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\nWe can also use the dollar sign accessor `$` to extract an element in a data frame or list. In the case of a data frame, you are accessing a column (though you could be accessing something else if a different type of object). Note that when you type the name of a data frame, and then the $, R will prompt you with some possible column names.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df$a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\nBy using this syntax, you are turning your data frame into a vector. This may or may not be what you want to do, so just be aware.\n\n::: {.callout-tip title=\"Accessing certain observations can also be performed using the `tidyverse` functions `select()` and `filter()`. If you don't know what I'm talking about simply ignore this, we will go over it in a future Code Club.\"}\n:::\n\n## Practice\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}