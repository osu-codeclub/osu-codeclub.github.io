{
  "hash": "11a61db8fccd7f1dc670ea72b311ec53",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Plotting geographical maps in R: part II\"\nsubtitle: \"Adding markers and text to maps.\"\npagetitle: \"Maps II\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2025-02-25\"\ncategories: [maps, ggplot2, dataviz]\ntitle-block-banner: false\nnumber-depth: 2\nexecute: \n  eval: true\n  cache: false\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n------------------------------------------------------------------------\n\n<br>\n\nToday is the second of a series of Code Club sessions on **making maps with R**.\n\nIn the [first session](../S09E05_maps_01/),\nwe learned the basics of making and formatting maps with ggplot functions.\n\nToday, we will learn how to **add points/markers and text** in various ways,\nand we will also see several data wrangling and general _ggplot_ tricks while\ndoing so.\n\n<br>\n\n## Setting up\n\n### Installing and loading R packages\n\nLast week, we realized during the session that two additional packages need to\nbe installed for some of the ggplot map-related functions to work,\nso let's make sure everyone has these installed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (! require(maps)) install.packages(\"maps\")\nif (! require(sf)) install.packages(\"sf\")\n```\n:::\n\n\n\nThe above type of code with the `if` statements is likely new to most of you.\nYou can read this code as:\n**if the package is not installed, _then_ install it**^[\nSpecifically, `! require(...)` will return `TRUE` if the package cannot be loaded\nbecause it is not installed --- and due to the `if()` statement, \nthe `install.packages(\"maps\")` will be executed _only_ if it returns `TRUE`.].\n\nAdditionally, we'll use a package with the quite specific purpose of\navoiding overlap between text labels in ggplots:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (! require(ggrepel)) install.packages(\"ggrepel\")\n```\n:::\n\n\n\nFinally, let's load these packages, along with the tidyverse:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(maps)\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n✖ purrr::map()    masks maps::map()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggrepel)\n```\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Picking up where we left off last week\n\nLike last week,\n\n- We'll set a ggplot theme for all the following plots:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_void())\ntheme_update(legend.position = \"top\")\n```\n:::\n\n\n\n- We'll load US state-wise map data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates <- map_data(map = \"state\")\n\nhead(states)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order  region subregion\n1 -87.46201 30.38968     1     1 alabama      <NA>\n2 -87.48493 30.37249     1     2 alabama      <NA>\n3 -87.52503 30.37249     1     3 alabama      <NA>\n4 -87.53076 30.33239     1     4 alabama      <NA>\n5 -87.57087 30.32665     1     5 alabama      <NA>\n6 -87.58806 30.32665     1     6 alabama      <NA>\n```\n\n\n:::\n:::\n\n\n\n- And create and store a base plot that we can build on:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(states) +\n  geom_polygon(\n    aes(x = long, y = lat, group = group),\n    fill = \"grey85\",\n    color = \"grey40\",\n    linewidth = 0.1\n    ) +\n  coord_sf(crs = 5070, default_crs = 4326)\n\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=85%}\n:::\n:::\n\n\n\n<br>\n\n## Adding markers and text to maps\n\n### Adding single text labels and points\n\nWe can add points to a map with the familiar geom `geom_point()`.\nWe have previously used this geom to make scatterplots based on data in a data frame,\nbut it can plot points at individually-specified locations, too.\n\nAs a first example, we'll just add a single point to show where the city of \nColumbus is,\nsetting its coordinates \"on the fly\" (_outside of_ `aes()`)\nand using the\n[OSU scarlet color via its Hex code](https://bux.osu.edu/color/primary-colors/)\nas the point color:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(x = -82.99, y = 39.99, colour = \"#ba0c2f\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=85%}\n:::\n:::\n\n\n\nWe can add arbitrary text labels in a similar way with the geom `geom_text()`,\nin which we specify the **text that we want to print using the `label` argument**\n(and note that I'm subtracting `1` from the latitude so the text ends up a bit below\nthe point and not right on top of it):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(x = -82.99, y = 39.99, colour = \"#ba0c2f\", size = 4) +\n  geom_text(x = -82.99, y = 39.99 - 1, label = \"Columbus\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=85%}\n:::\n:::\n\n\n\n### Adding a set of points from a data frame\n\nIn your research, you may want to make a map that plots sampling locations.\nAs a simple fictional example,\nwe can create a dataframe with four sampling locations, a grouping factor\n(`season`), and a column with a numerical result for each location (`yield`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocations <- data.frame(\n  location = c(\"L01\", \"L02\", \"L03\", \"L04\"),\n  long = c(-80, -100, -90, -110),\n  lat = c(35, 33, 45, 43),\n  season = c(\"winter\", \"winter\", \"summer\", \"summer\"),\n  yield = c(16, 97, 39, 66)\n)\n\nlocations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  location long lat season yield\n1      L01  -80  35 winter    16\n2      L02 -100  33 winter    97\n3      L03  -90  45 summer    39\n4      L04 -110  43 summer    66\n```\n\n\n:::\n:::\n\n\n\nNow, we can add a layer to our saved plot `p` with the sampling locations ---\nnote that:\n\n- We are giving `geom_point()` \"its own\" data set with the `data =` argument\n- We map the `fill` aesthetic to the `season` column so we can distinguish\n  samples from different seasons\n- We use point shape 21\n  (see [this overview of R point shapes](https://www.sthda.com/english/wiki/ggplot2-point-shapes)),\n  which allows for a `fill` color\n  (separate from the outline color which can be set with `color`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np +\n  geom_point(\n    data = locations,\n    aes(x = long, y = lat, fill = season),\n    size = 4,\n    shape = 21\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=85%}\n:::\n:::\n\n\n\n::: exercise\n### {{< fa user-edit >}} Exercise 1\n\nBuild on the previous map by making the appearance of the sampling location points\nreflect the values in the `yield` column.\nFor example, higher yields could produce larger points, or the fill color of the\npoints could depend on the yield.\n\n<details><summary>Click here for some hints</summary>\n\n- To make points vary in size, use the `size` aesthetic `aes(size = ...)`\n\n- To make points vary in fill color, use the `fill` aesthetic and then switch to\n  a different aesthetic for `season`, like point `shape`.\n\n</details>\n\n<details><summary>Click here for possible solutions with point size</summary>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n- Make points vary in size according to the values in the `yield` column\n  by including `size = yield` inside `aes()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_size <- p + \n  geom_point(\n    data = locations,\n    aes(x = long, y = lat, fill = season, size = yield),\n    shape = 21\n    )\n\np_size\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=85%}\n:::\n:::\n\n\n\n- As an aside,\n  the above legend had quite a small point size for the location with the lowest\n  yield -- to improve that,\n  we can expand the `limits` of the scale,\n  and optionally also play around with the `range` of point sizes and the\n  `breaks`, i.e. the values that get displayed in the legend:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_size +\n  scale_size_continuous(\n    limits = c(0, 100),\n    breaks = c(10, 50, 100),\n    range = c(1, 10)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n<details><summary>Click here for possible solutions with point fill color</summary>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n- If we want to use `fill` color instead for `yield`,\n  we'll need a different aesthetic for `season`, e.g. `shape`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_fill <- p +\n  geom_point(\n    data = locations,\n    aes(x = long, y = lat, shape = season, fill = yield),\n    size = 5\n    ) +\n  # Make sure the shapes support a fill color (the default ones don't):\n  scale_shape_manual(values = c(21, 23))\n\np_fill\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=85%}\n:::\n:::\n\n\n\n- For a nicer-looking fill color scale, we can change to one of the\n  [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)\n  color scales:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_fill +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n:::\n\n<br>\n\n## A county-level map of Ohio\n\nThe background map we've been working with so far doesn't have county lines.\nBut in some cases, like when making a map of single state such as Ohio,\nthose would come in handy.\n\n### Getting county-level map data for just Ohio\n\nWe can get a county-level map of the entire United States using\n`map_data(map = \"county\")`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_data(map = \"county\") |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order  region subregion\n1 -86.50517 32.34920     1     1 alabama   autauga\n2 -86.53382 32.35493     1     2 alabama   autauga\n3 -86.54527 32.36639     1     3 alabama   autauga\n4 -86.55673 32.37785     1     4 alabama   autauga\n5 -86.57966 32.38357     1     5 alabama   autauga\n6 -86.59111 32.37785     1     6 alabama   autauga\n```\n\n\n:::\n:::\n\n\n\nWe will filter this dataframe so we are only left with data from Ohio:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio <- map_data(map = \"county\") |>\n  filter(region == \"ohio\")\n\nhead(ohio)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order region subregion\n1 -83.66902 39.02989  2012 59960   ohio     adams\n2 -83.56590 39.02989  2012 59961   ohio     adams\n3 -83.37109 39.06426  2012 59962   ohio     adams\n4 -83.30806 39.06426  2012 59963   ohio     adams\n5 -83.30233 39.05280  2012 59964   ohio     adams\n6 -83.25649 39.01842  2012 59965   ohio     adams\n```\n\n\n:::\n:::\n\n\n\nLet's get a feel for what's in the resulting dataframe --- the only `region`\n(i.e. state) should be `ohio`, and `subregion`s represent counties:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio |> count(region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  region    n\n1   ohio 1427\n```\n\n\n:::\n\n```{.r .cell-code}\nohio |> count(subregion) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  subregion  n\n1     adams 17\n2     allen 16\n3   ashland 17\n4 ashtabula 11\n5    athens 19\n6  auglaize 16\n```\n\n\n:::\n:::\n\n\n\nThe number of entries for each county (`n` in the output above)\nis simply how many points make up the lines.\nThose numbers are quite low, making this a relatively low-resolution map ---\nbut good enough for our purposes.\n\n### A base map of Ohio\n\nNow we are ready to plot our first map of Ohio:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio <- ggplot(ohio) +\n  geom_polygon(\n    aes(x = long, y = lat, group = group),\n    fill = \"grey90\",\n    color = \"grey70\"\n    ) +\n  coord_sf()\n\np_ohio\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=85%}\n:::\n:::\n\n\n\nWe can use this as a **base map** to plot points on,\nlike we did above with the US map.\nOr we could create a map where counties differ in fill color depending on some\nvariable, like the number of farms or eagle nests in each county.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Adding county names\n\nFor now, without pulling in additional data,\nsay that we want to **print the county names in the map**.\n\nThe county names are in all-lowercase,\nso let's start by transforming to **\"Title Case\"** using the\n`tools::toTitleCase()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nohio <- ohio |>\n  mutate(subregion = tools::toTitleCase(subregion))\n\nhead(ohio)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order region subregion\n1 -83.66902 39.02989  2012 59960   ohio     Adams\n2 -83.56590 39.02989  2012 59961   ohio     Adams\n3 -83.37109 39.06426  2012 59962   ohio     Adams\n4 -83.30806 39.06426  2012 59963   ohio     Adams\n5 -83.30233 39.05280  2012 59964   ohio     Adams\n6 -83.25649 39.01842  2012 59965   ohio     Adams\n```\n\n\n:::\n:::\n\n\n\nBut if we now add text labels with `geom_text()` using the `subregion` colum,\nwe'll get the following terrible map:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_text(\n    aes(x = long, y = lat, label = subregion),\n    color = \"darkblue\",\n    size = 3\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>**Why is this happening?**</summary>\n<hr style=\"height:1pt; visibility:hidden;\" />\nThe reason is that each county has a number of rows in the dataframe:\none for each point that makes up its border.\nAnd right now, we're printing the county label for every single point.\n<hr style=\"height:1pt; visibility:hidden;\" />\n</details>\n\nSo, we'll need a _single pair of coordinates for each county_ to print each\ncounty name once,\nand those should be in the **center of each county**.\nTherefore, we'll need to compute some kind of approximation of the county centers.\n\nTaking the **mean of the border-coordinates** for each county could be a start,\nbut looking at the positions of the text labels in the map above,\ncan you think of a reason why that may not be optimal?\n\n<details><summary>Click for the answer</summary>\n<hr style=\"height:1pt; visibility:hidden;\" />\nThere are more points in irregularly-shaped (i.e., not straight lines) parts \nof the border.\nIn practice, those tend be on specific sides of the border\n(e.g., look at the western border of Ohio and the counties there),\nso the mean values will be drawn towards those sides.\nUsing the median wouldn't help.\n<hr style=\"height:1pt; visibility:hidden;\" />\n</details>\n\nA better --though still not perfect-- way to compute this is by subtracting,\nfor both latitude and longitude,\n**half of the _range_** (max. - min.) from the maximum value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_coords <- ohio |>\n  summarize(\n    long = max(long) - ((max(long) - min(long)) / 2),\n    lat = max(lat) - ((max(lat) - min(lat)) / 2),\n    .by = subregion\n    )\n\nhead(county_coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  subregion      long      lat\n1     Adams -83.47995 38.84367\n2     Allen -84.14172 40.78887\n3   Ashland -82.28247 40.82324\n4 Ashtabula -80.76986 41.73425\n5    Athens -82.00745 39.37939\n6  Auglaize -84.17036 40.52244\n```\n\n\n:::\n:::\n\n\n\nNow, we can add the county labels to the plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_text(\n    data = county_coords,\n    aes(x = long, y = lat, label = subregion),\n    color = \"darkblue\",\n    size = 3\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=85%}\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Exercise 2\n\n**A)** OSU has campuses in the following places:\n\n- Columbus, Franklin County\n- Wooster, Wayne County\n- Lima, Allen County\n- Mansfield, Richland County\n- Marion, Marion County\n- Newark, Licking County\n\nCan you create a map similar to our previous one,\nbut then with only these 6 counties labeled by name?\nLike in the example below:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>Click here for some hints</summary>\n\n- You'll have to `filter()` the `county_coords` data frame to only keep the \n  counties of interest.\n  \n- After that, the plotting code will be identical to that for the previous map,\n  just make sure you pass the correct, filtered data frame.\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n- First we filter the `county_coords` to only keep our focal counties,\n  and store the result in a new data frame:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal_counties <- c(\"Franklin\", \"Wayne\", \"Allen\",\n                    \"Richland\", \"Marion\", \"Licking\") \n\ncounty_coords_sel <- county_coords |>\n  filter(subregion %in% focal_counties)\n```\n:::\n\n\n\n- We use the same plotting code as before, but now with `county_coords_sel`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_text(\n    data = county_coords_sel,\n    aes(x = long, y = lat, label = subregion),\n    color = \"darkblue\",\n    size = 4\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=85%}\n:::\n:::\n\n\n\n</details>\n\n<br>\n\n**B) (Bonus)** Can you produce a map that has a different fill color for each\ncounty, like the one below?\n\n\n\n::: {.cell .preview-image}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>Click here for some hints</summary>\n\n- You'll want to keep the original `geom_polygon()` layer with the gray counties\n  (i.e., you can start with the `p_ohio` map),\n  and then add a **second** `geom_polygon()` layer that only has the selected counties.\n  \n- In that second layer, map the `county` column to the `fill` aesthetic.\n\n- Make sure to add the `geom_text()` layer last,\n  or it would be masked by the polygon layer.\n\n- If you're printing the names of the counties,\n  then you won't need a legend:\n  you can turn that off using `theme(legend.position = \"none\")`.\n  \n</details>\n\n<details><summary>Click here for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio +\n  geom_polygon(\n    data = ohio |> filter(subregion %in% focal_counties),\n    aes(x = long, y = lat, group = group, fill = subregion),\n    color = \"grey70\"\n    ) +\n  geom_text(\n    data = county_coords_sel,\n    aes(x = long, y = lat, label = subregion),\n    color = \"darkblue\",\n    size = 4\n    ) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=85%}\n:::\n:::\n\n\n</details>\n\n:::\n\n<br>\n\n## Plotting Ohio cities\n\nFinally, we'll add all larger Ohio cities to our Ohio map.\nFrom the _maps_ package, we can use the `us.cities` dataframe which contains\nUS cities with populations greater than about 40,000:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 'us.cities' should be available if you have loaded the maps package\nhead(us.cities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        name country.etc    pop   lat    long capital\n1 Abilene TX          TX 113888 32.45  -99.74       0\n2   Akron OH          OH 206634 41.08  -81.52       0\n3 Alameda CA          CA  70069 37.77 -122.26       0\n4  Albany GA          GA  75510 31.58  -84.18       0\n5  Albany NY          NY  93576 42.67  -73.80       2\n6  Albany OR          OR  45535 44.62 -123.09       0\n```\n\n\n:::\n:::\n\n\n\nLet's pre-process this data a bit by:\n\n- Only taking Ohio cities with populations over 50,000\n- Stripping the state-abbreviation suffix that all cities have, as we saw above.\n  Since we are left with only Ohio cities,\n  we can therefore simply remove ` OH` from the `name`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noh_cities <- us.cities |>\n  filter(country.etc == \"OH\", pop > 50000) |>\n  # We'll use the sub() function to substitute \" OH\" with nothing (\"\"):\n  mutate(name = sub(pattern = \" OH\", replacement = \"\", x = name))\n\nhead(oh_cities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            name country.etc    pop   lat   long capital\n1          Akron          OH 206634 41.08 -81.52       0\n2         Canton          OH  77575 40.81 -81.37       0\n3     Cincinnati          OH 301561 39.14 -84.51       0\n4      Cleveland          OH 443949 41.48 -81.68       0\n5       Columbus          OH 741677 39.99 -82.99       2\n6 Cuyahoga Falls          OH  52223 41.17 -81.52       0\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Adding city points\n\nNow, let's add these cities to our Ohio base map (`p_ohio`),\nwith larger points for larger cities:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities <- p_ohio +\n  geom_point(\n    data = oh_cities,\n    aes(x = long, y = lat, size = pop),\n    fill = \"steelblue3\",\n    shape = 21\n    )\n\np_ohio_cities\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=85%}\n:::\n:::\n\n\n\n### Adding city names\n\nNext, let's add the names of the cities with `geom_text()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities +\n  geom_text(\n    data = oh_cities,\n    aes(x = long, y = lat + 0.1, label = name)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=85%}\n:::\n:::\n\n\n\nOuch, there are a lot of overlapping labels there!\nWe can avoid this with a drop-in replacement for `geom_text()` named\n`geom_text_repel()` from the _ggrepel_ package: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities_labeled <- p_ohio_cities +\n  geom_text_repel(\n    data = oh_cities,\n    aes(x = long, y = lat, label = name)\n    )\n\np_ohio_cities_labeled\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=85%}\n:::\n:::\n\n\n\n### Side note: A better legend\n\nWe may want to change the `size` legend a bit:\n\n- Its title is `pop`, which we can change to e.g. `Population size`.\n- The scientific notation of the population sizes is cumbersome to read,\n  and we can change it to a notation with a comma as a thousands-separator\n  (`13,000`, etc.) using `labels = scales:comma`.\n- The range of the legend entries (breaks) is quite a bit more restricted\n  than the sizes of our cites (200-600k versus 50-740k),\n  so we may want to get a better range by manually defining breaks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities_labeled +\n  scale_size_continuous(\n    name = \"Population size\",\n    labels = scales::comma,\n    breaks = c(100, 400, 700) * 1000\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=85%}\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n#### Want to further expand the range of the legend's scale breaks? _(Click to expand)_\n_ggplot_ will refuse to include `breaks` in the legend that are outside of the\nscale's limits, which are by default the range of the data.\nBecause the smallest city in the dataset is just larger than 50,000,\nand the largest city is just smaller than 750,000  (see below),\nsetting breaks to these values will therefore not work unless we expand the\nscale's limits with the `limits` argument.\n\nCheck what the range of population sizes is (min. and max.):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(oh_cities$pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  50010 741677\n```\n\n\n:::\n:::\n\n\n\nOr if we wanted to see which cities these are:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noh_cities |> arrange(pop) |> head(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name country.etc   pop   lat   long capital\n1 Mansfield          OH 50010 40.76 -82.53       0\n```\n\n\n:::\n\n```{.r .cell-code}\noh_cities |> arrange(desc(pop)) |> head(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name country.etc    pop   lat   long capital\n1 Columbus          OH 741677 39.99 -82.99       2\n```\n\n\n:::\n:::\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nBreaks at `50` and `750` will be **ignored** by default (!),\nbecause they are outside of the scale's limits:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities_labeled +\n  scale_size_continuous(\n    name = \"Population size\",\n    labels = scales::comma,\n    breaks = c(50, 100, 250, 500, 750) * 1000\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=85%}\n:::\n:::\n\n\n\nIf we also **expand the `limits`** of the scale,\nwe _can_ include breaks at `50` and `750`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities_labeled +\n  scale_size_continuous(\n    name = \"Population size\",\n    labels = scales::comma,\n    limits = c(50, 750) * 1000,\n    breaks = c(50, 100, 250, 500, 750) * 1000\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=85%}\n:::\n:::\n\n\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Bonus exercise\n\nCan you produce a map in which the names of cities with a population larger than\n100,000 are in a **_bold italic_** (`bold.italic`) fontface,\nwhereas those of smaller cities are in regular (`plain`) fontface?\n\nSee the example below:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=85%}\n:::\n:::\n\n\n\n<details><summary>Click here for some hints</summary>\n\n- Using `mutate()` with an `ifelse()` statement,\n  you'll first want to create a column that specifies whether or not a city\n  has a population larger than 100,000.\n\n- Next, you can map that newly created column to the `fontface` aesthetic\n  (`aes(fontface = ...)`).\n\n- The `fontface` aesthetic is a bit unusual,\n  so using it like you would say the `size` or `color` aesthetic doesn't quite work.\n  Take a look at the\n  [example in the ggplot docs](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#font-face)\n  and see if you can figure out how to use it.\n\n</details>\n\n<details><summary>Click here for the solution</summary>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n- First, we create a new column `is_large` that indicates whether a city has more\n  than 100,000 inhabitants.\n  Instead of coding this column with `TRUE`/`FALSE` (see below),\n  we'll need to directly use the specific fontfaces we want to display for each\n  type of city:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noh_cities <- oh_cities |>\n  mutate(is_large = ifelse(pop > 100000, \"bold.italic\", \"plain\"))\n```\n:::\n\n\n\n- Next, we can map the `fontface` aesthetic to the `is_large` column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_ohio_cities +\n  geom_text_repel(\n    data = oh_cities,\n    aes(x = long, y = lat, label = name, fontface = is_large)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=85%}\n:::\n:::\n\n\n\n- If we were using any other aesthetic (e.g. `fill`),\n  we would probably use `TRUE`/`FALSE` in the focal column instead,\n  and that would work --- but it returns an error here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noh_cities <- oh_cities |>\n  mutate(is_large = ifelse(pop > 100000, TRUE, FALSE))\n\np_ohio_cities +\n  geom_text_repel(\n    data = oh_cities,\n    aes(x = long, y = lat, label = name, fontface = is_large)\n    )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in FUN(X[[i]], ...): invalid fontface TRUE\n```\n\n\n:::\n:::\n\n\n\nAlong the same lines, there are no `scale_fontface` functions to set the fontfaces:\nthis instead has to be done with the values in the column.\n\n</details>\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}