{
  "hash": "6e1891b12c178720f08151ae8292cfd9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidyverse 3: Grouping and Summarizing Data\"\nauthor: \"Jelmer Poelstra\"\ndate: \"2024-03-01\"\ncategories: [r-basics, tidyverse]\ntitle-block-banner: false\nnumber-depth: 3\nimage: img/dplyr.jpeg\neditor_options:\n  chunk_output_type: console\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\n    class-output: styled-output\n---\n\n\n------------------------------------------------------------------------\n\n<br>\n\n## Introduction\n\n#### Recap of the past two weeks\n\nIn the past two weeks, we've been learning about 5 functions from the _dplyr_ package,\na central workhorse of the tidyverse ecosystem, to manipulate data in data frames:\n\n- `filter()` to pick rows (which typically represent observations/samples/individuals)\n- `select()` to pick columns (which typically represent variables/properties)\n- `arrange()` to sort data frame rows\n- `rename()` to change data frame column names\n- `mutate()` to add and manipulate data frame columns\n\n#### Learning objectives for today\n\nToday, we will focus on a slightly more complicated and very powerful _dplyr_ function:\n`summarize()` to compute summaries across rows, typically across **groups of rows**.\n\nWe will also learn about a couple other handy functions to work with groups of rows:\nthe `slice_()` family of functions and `count()`.\n\n#### Setting up\n\nLoad the tidyverse:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n::: {.callout-warning collapse=\"true\"}\n#### Still need to install the tidyverse? _Click here for instructions_\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n:::\n\nWe'll continue working with the `diamonds` dataframe (automatically loaded with the tidyverse),\nso let's take another look at that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n```\n\n\n:::\n:::\n\n\n<br>\n\n## `summarize()`\n\n### A first example\n\nThe [`summarize()` function from the _dplyr_ package](https://dplyr.tidyverse.org/reference/summarise.html)\ncan compute across-row data summaries.\nAs a first example, here's how you can compute the overall mean of the `carat` column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(carat_mean = mean(carat))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 1 × 1\n  carat_mean\n       <dbl>\n1      0.798\n```\n\n\n:::\n:::\n\n\nAs you can see, this function has quite a different output from the _dplyr_ functions we'd seen so far.\nAll of those returned a manipulated version of our original dataframe,\nwhereas `summarize()` returns a \"completely new\" dataframe with a summary of the original data.\n\nHowever, summarizing across all rows at once with `summarize()` is much more verbose\nthan the simple, base R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(diamonds$carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n[1] 0.7979397\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Summarizing by group \n\nThe real power of `summarize()` comes with its ability to compute **group-wise summaries**.\nFor example, simply by adding `.by = cut`,\nit will calculate the mean `carat` separately for each value of `cut`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(carat_mean = mean(carat), .by = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 2\n  cut       carat_mean\n  <ord>          <dbl>\n1 Ideal          0.703\n2 Premium        0.892\n3 Good           0.849\n4 Very Good      0.806\n5 Fair           1.05 \n```\n\n\n:::\n:::\n\n\nNice! We can also compute multiple summarized variables ---\nand use summarizing functions other than `mean()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(carat_mean = mean(carat),\n            carat_max = max(carat),\n            .by = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 3\n  cut       carat_mean carat_max\n  <ord>          <dbl>     <dbl>\n1 Ideal          0.703      3.5 \n2 Premium        0.892      4.01\n3 Good           0.849      3.01\n4 Very Good      0.806      4   \n5 Fair           1.05       5.01\n```\n\n\n:::\n:::\n\n\nA handy helper function is **`n()`**, which will compute the **number of rows for each group**\n(i.e. the group sizes, which can be good to know,\nfor example so you don't make unfounded conclusions based on really small sample sizes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(carat_mean = mean(carat),\n            n_diamonds = n(),\n            .by = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 3\n  cut       carat_mean n_diamonds\n  <ord>          <dbl>      <int>\n1 Ideal          0.703      21551\n2 Premium        0.892      13791\n3 Good           0.849       4906\n4 Very Good      0.806      12082\n5 Fair           1.05        1610\n```\n\n\n:::\n:::\n\n\nHere is an overview of the most commonly used functions to compute summaries:\n\n- `mean()` & `median()`\n- `min()` & `max()`\n- `sum()`\n- `sd()`: standard deviation\n- `IQR()`: interquartile range\n- `n()`: counts the number of rows (observations)\n- `n_distinct()`: counts the number of distinct (unique) values\n\nTwo other comments:\n\n- You can also ask `summarize()` to compute summaries by **multiple columns**,\n  which will return separate summaries for each _combination_ of the involved variables ---\n  we'll see this in the exercises.\n\n- This may be obvious, but whatever column you are computing summaries by\n  (using `.by`) should be a **categorical variable**.\n  In our `diamond` examples, we're only using columns that are `factor`s,\n  but \"regular\" `character` columns will work just fine as well.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-note\n### Side note: `group_by()`\n\nThe \"classic\" way of using `summarize()` with multiple groups is by preceding\nit with a `group_by()` call ---\ne.g., the code below is equivalent to our last example above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  group_by(cut) |> \n  summarize(carat_mean = mean(carat),\n            n_diamonds = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 3\n  cut       carat_mean n_diamonds\n  <ord>          <dbl>      <int>\n1 Fair           1.05        1610\n2 Good           0.849       4906\n3 Very Good      0.806      12082\n4 Premium        0.892      13791\n5 Ideal          0.703      21551\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nThe `.by` argument to `summarize()` (and other functions!) is a rather recent addition,\nbut I prefer it over `group_by()`:\n\n- It is simpler, a bit less typing, and makes the `summarize()` call self-contained\n- When grouping by multiple columns, `group_by()` has some odd, unhelpful behavior\n  where it keeps some of the groupings, such that you likely need an `ungroup()` call as well.\n\n:::\n\n<br>\n\n::: exercise\n## Exercises I\n\n### Diamond sizes in relation to `clarity`\n\n**A)** Compute the mean length (`x`), width (`y`), and depth (`z`) for each diamond `clarity`.\nAlso include a column with group sizes. Do you see any clear differences?\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(x_mean = mean(x),\n            y_mean = mean(y),\n            z_mean = mean(z),\n            n_diamonds = n(),\n            .by = clarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 8 × 5\n  clarity x_mean y_mean z_mean n_diamonds\n  <ord>    <dbl>  <dbl>  <dbl>      <int>\n1 SI2       6.40   6.40   3.95       9194\n2 SI1       5.89   5.89   3.64      13065\n3 VS1       5.57   5.58   3.44       8171\n4 VS2       5.66   5.66   3.49      12258\n5 VVS2      5.22   5.23   3.22       5066\n6 VVS1      4.96   4.98   3.06       3655\n7 I1        6.76   6.71   4.21        741\n8 IF        4.97   4.99   3.06       1790\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** Diamond size differences between clarities may become more apparent if we use the overall volume:\n\n- Dig up your `mutate()` skills to create a volume column `vol` (length * width * depth)\n- Compute the mean volume for each diamond `clarity`\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  mutate(vol = x * y * z) |>\n  summarize(vol_mean = mean(vol), .by = clarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 8 × 2\n  clarity vol_mean\n  <ord>      <dbl>\n1 SI2        175. \n2 SI1        138. \n3 VS1        119. \n4 VS2        124. \n5 VVS2        97.6\n6 VVS1        82.5\n7 I1         205. \n8 IF          83.3\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Diamond prices\n\n**A)** For each diamond `cut`, compute the `price`'s mean, median, minimum, maximum, and standard deviation.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(price_mean = mean(price),\n            price_median = median(price),\n            price_min = min(price),\n            price_max = max(price),\n            price_sd = sd(price),\n            .by = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 6\n  cut       price_mean price_median price_min price_max price_sd\n  <ord>          <dbl>        <dbl>     <int>     <int>    <dbl>\n1 Ideal          3458.        1810        326     18806    3808.\n2 Premium        4584.        3185        326     18823    4349.\n3 Good           3929.        3050.       327     18788    3682.\n4 Very Good      3982.        2648        336     18818    3936.\n5 Fair           4359.        3282        337     18574    3560.\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** Find the combination of `cut`, `color`, and `clarity` that on average yields\nthe most expensive diamonds.\n\nFor this, you'll have to group by all these 3 columns.\nTry this for yourself first, but check out the first solution if you can't get that part to work.\n\n<details><summary><b>Grouping solution</b> (click here)</summary>\n\n`.by = c(cut, color, clarity)` will group by these 3 columns at once.\n\n</details>\n\n<details><summary><b>Solution</b> (click here)</summary>\n\nAfter summarizing, it makes sense to arrange in descending order by price,\nso you can see the cut-color-clarity combinations with the most expensive diamonds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  summarize(price = mean(price),\n            .by = c(cut, color, clarity)) |>\n  arrange(desc(price))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 276 × 4\n   cut       color clarity  price\n   <ord>     <ord> <ord>    <dbl>\n 1 Very Good D     IF      10298.\n 2 Good      D     IF      10030.\n 3 Ideal     J     I1       9454 \n 4 Premium   D     IF       9056.\n 5 Premium   J     SI2      7550.\n 6 Fair      D     I1       7383 \n 7 Premium   J     VVS1     7244.\n 8 Ideal     I     SI2      7192.\n 9 Premium   I     VS2      7156.\n10 Premium   I     SI2      7148.\n# ℹ 266 more rows\n```\n\n\n:::\n:::\n\n\n</details>\n\n:::\n\n<br>\n\n## The `slice_` functions\n\nLike the `filter()` function, [functions in the `slice_` family](https://dplyr.tidyverse.org/reference/slice.html)\nselect specific rows,\nbut have some different functionality that's quite handy ---\nespecially in combination with grouping.\n\nLet's say we wanted to only get, **for each `cut`, the diamond with the highest value of `carat`**.\nWe can do this pretty easily with the `slice_max()` function,\nwhich will return the row(s) with the highest value for a specified variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  slice_max(carat, by = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 8 × 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  3.5  Ideal     H     I1       62.8    57 12587  9.65  9.59  6.03\n2  4.01 Premium   I     I1       61      61 15223 10.1  10.1   6.17\n3  4.01 Premium   J     I1       62.5    62 15223 10.0   9.94  6.24\n4  3.01 Good      I     SI2      63.9    60 18242  9.06  9.01  5.77\n5  3.01 Good      I     SI2      63.9    60 18242  9.06  9.01  5.77\n6  3.01 Good      H     SI2      57.6    64 18593  9.44  9.38  5.42\n7  4    Very Good I     I1       63.3    58 15984 10.0   9.94  6.31\n8  5.01 Fair      J     I1       65.5    59 18018 10.7  10.5   6.98\n```\n\n\n:::\n:::\n\n\n<details><summary>Why are we getting more than one diamond per `cut` in some cases? _(Click to see the answer)_</summary>\nBecause of ties in the `cut` value. (We'll get back to this in the next set of exercises.)\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nYou can get more than just the single highest (`slice_max()`) / lowest (`slice_min()`)\nvalue per group with the `n=` argument,\nand can get a specific proportion of rows with `prop=`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the 3 highest-depth diamonds for each value of cut\ndiamonds |>\n  slice_max(depth, by = cut, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 280 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  2.01 Ideal   I     VS2      66.7    56 15729  7.75  7.65  5.14\n 2  0.71 Ideal   E     SI2      65.5    55  2511  5.62  5.56  3.66\n 3  3.01 Ideal   J     I1       65.4    60 16538  8.99  8.93  5.86\n 4  0.8  Premium G     SI1      63      59  2760  5.9   5.81  3.69\n 5  0.9  Premium I     VS2      63      58  2761  6.16  6.12  3.87\n 6  0.72 Premium I     IF       63      57  2795  5.72  5.7   3.6 \n 7  0.72 Premium E     VS2      63      55  2802  5.79  5.61  3.59\n 8  0.7  Premium E     VS2      63      60  2818  5.64  5.6   3.54\n 9  0.81 Premium G     SI1      63      60  2832  5.87  5.81  3.68\n10  0.7  Premium G     VS1      63      60  2838  5.64  5.57  3.53\n# ℹ 270 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the 1% lowest-carat diamonds for each value of color\ndiamonds |>\n  slice_min(carat, by = color, prop = 0.01)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 926 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.2  Premium   E     SI2      60.2    62   345  3.79  3.75  2.27\n 2  0.2  Premium   E     VS2      59.8    62   367  3.79  3.77  2.26\n 3  0.2  Premium   E     VS2      59      60   367  3.81  3.78  2.24\n 4  0.2  Premium   E     VS2      61.1    59   367  3.81  3.78  2.32\n 5  0.2  Premium   E     VS2      59.7    62   367  3.84  3.8   2.28\n 6  0.2  Ideal     E     VS2      59.7    55   367  3.86  3.84  2.3 \n 7  0.2  Very Good E     VS2      63.4    59   367  3.74  3.71  2.36\n 8  0.2  Ideal     E     VS2      62.2    57   367  3.76  3.73  2.33\n 9  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n10  0.21 Very Good E     VS2      63.2    54   386  3.82  3.78  2.4 \n# ℹ 916 more rows\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-note\n#### The full set of `slice_` functions\n\n- `slice_head(n = 1)` takes the first row.\n- `slice_tail(n = 1)` takes the last row\n- `slice_min(x, n = 1)` takes the row with the smallest value in column `x`.\n- `slice_max(x, n = 1)` takes the row with the largest value in column `x`.\n- `slice_sample(n = 1)` takes one random row.\n- `slice(15)` takes the 15th row.\n:::\n\n<br>\n\n## The `count()` function\n\nAbove, we used the `n()` helper with `summarize()` to get the number of rows\nwith each value of `cut` (i.e. the group sizes) along with other computed summaries.\n\nGetting a \"count table\" like that is such a common part of Exploratory Data Analysis (EDA)\nthat there's another _dplyr_ function available for it,\n[`count()`](https://dplyr.tidyverse.org/reference/count.html).\nAnd unless you're already `summarize`-ing, this one is simpler to use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> count(cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 2\n  cut           n\n  <ord>     <int>\n1 Fair       1610\n2 Good       4906\n3 Very Good 12082\n4 Premium   13791\n5 Ideal     21551\n```\n\n\n:::\n:::\n\n\nWe may also want to sort the output by frequency, which can be useful\nespecially when there are many different values for the focal variable\n(not really the case here, but you get the point):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> count(cut, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 2\n  cut           n\n  <ord>     <int>\n1 Ideal     21551\n2 Premium   13791\n3 Very Good 12082\n4 Good       4906\n5 Fair       1610\n```\n\n\n:::\n:::\n\n\nAnd you can also create counts for value combinations across multiple columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> count(cut, color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 35 × 3\n   cut   color     n\n   <ord> <ord> <int>\n 1 Fair  D       163\n 2 Fair  E       224\n 3 Fair  F       312\n 4 Fair  G       314\n 5 Fair  H       303\n 6 Fair  I       175\n 7 Fair  J       119\n 8 Good  D       662\n 9 Good  E       933\n10 Good  F       909\n# ℹ 25 more rows\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-tip\n#### Base R's `table()` function\n\nAlso worth mentioning is the base R `table()` function, which is similar to `count()`.\nWhile its output format is unwieldy for follow-up analyses^[It's not actually a data frame...],\nyou may prefer its formatting especially when wanting to glance at a 2-way count table to see patterns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(diamonds$cut, diamonds$color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n           \n               D    E    F    G    H    I    J\n  Fair       163  224  312  314  303  175  119\n  Good       662  933  909  871  702  522  307\n  Very Good 1513 2400 2164 2299 1824 1204  678\n  Premium   1603 2337 2331 2924 2360 1428  808\n  Ideal     2834 3903 3826 4884 3115 2093  896\n```\n\n\n:::\n:::\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nAdditionally, as a _dplyr_ function, `count()` only works with data frames.\nOccasionally, you may also need to create a count table for a **vector**, and `table()` can do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncut_vec <- diamonds$cut\n\ntable(cut_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\ncut_vec\n     Fair      Good Very Good   Premium     Ideal \n     1610      4906     12082     13791     21551 \n```\n\n\n:::\n:::\n\n\n:::\n\n<br>\n\n::: exercise\n## Exercises II\n\n### No ties, please\n\nAbove, when we first used `slice_max()`, we got multiple rows for some groups.\nCheck out the help for this function (`?slice_max`) and get it to print only one row per group,\neven in the case of ties.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\nThe `with_ties` argument controls this. The default is `TRUE` (do include ties),\nso we want to set it to `FALSE` (don't include ties):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  slice_max(carat, by = cut, with_ties = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 5 × 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  3.5  Ideal     H     I1       62.8    57 12587  9.65  9.59  6.03\n2  4.01 Premium   I     I1       61      61 15223 10.1  10.1   6.17\n3  3.01 Good      I     SI2      63.9    60 18242  9.06  9.01  5.77\n4  4    Very Good I     I1       63.3    58 15984 10.0   9.94  6.31\n5  5.01 Fair      J     I1       65.5    59 18018 10.7  10.5   6.98\n```\n\n\n:::\n:::\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Random diamonds\n\nUse `slice_sample()` to get 5 random diamonds for each combination of `cut`, `color` and `clarity`.\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  slice_sample(n = 5, by = c(cut, color, clarity))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 1,342 × 10\n   carat cut     color clarity depth table price     x     y     z\n   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  1.2  Ideal   E     SI2      61.3  56    6006  6.85  6.88  4.21\n 2  1.02 Ideal   E     SI2      62.6  54.6  4983  6.4   6.44  4.02\n 3  0.78 Ideal   E     SI2      61    56    3053  5.92  5.98  3.63\n 4  1.11 Ideal   E     SI2      61.2  57    4969  6.7   6.74  4.11\n 5  1    Ideal   E     SI2      60.7  55    4077  6.39  6.33  3.86\n 6  0.71 Premium E     SI1      60.3  60    2674  5.77  5.74  3.47\n 7  0.82 Premium E     SI1      61.2  61    3211  5.98  5.95  3.65\n 8  0.51 Premium E     SI1      61.3  54    1546  5.18  5.13  3.16\n 9  0.57 Premium E     SI1      62.2  55    1590  5.36  5.31  3.32\n10  0.41 Premium E     SI1      62.4  58     755  4.75  4.77  2.97\n# ℹ 1,332 more rows\n```\n\n\n:::\n:::\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `count()`\n\n**A)** Create a sorted count table of diamond `clarity`s\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> count(clarity, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 8 × 2\n  clarity     n\n  <ord>   <int>\n1 SI1     13065\n2 VS2     12258\n3 SI2      9194\n4 VS1      8171\n5 VVS2     5066\n6 VVS1     3655\n7 IF       1790\n8 I1        741\n```\n\n\n:::\n:::\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B)** What are the least common combinations of `clarity` and `depth`\n   for diamonds costing less than $5,000?\n\n<details><summary><b>Hints</b> (click here)</summary>\n\n- You'll have to `filter()` first.\n- Can you sort in reverse order with `count()`? If not, you'll have to use a separate `arrange()`\n\n</details>\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  filter(price < 5000) |> \n  count(clarity, color) |>\n  arrange(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 56 × 3\n   clarity color     n\n   <ord>   <ord> <int>\n 1 I1      J        26\n 2 I1      D        32\n 3 IF      D        39\n 4 IF      J        40\n 5 VVS1    J        51\n 6 I1      I        65\n 7 VVS2    J        67\n 8 I1      E        84\n 9 I1      H       108\n10 I1      G       114\n# ℹ 46 more rows\n```\n\n\n:::\n:::\n\n</details>\n\n-----\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Bonus: sort then slice\n\n`slice_head()` will print the _first-occurring_ row(s),\nand its twin `slice_tail()` prints the _last_ row(s).\nIn combination with sorting, these can give more flexibility than the min-max functions.\n\nFor each `color`, use `arrange()` and `slice_head()` to get the 3 diamonds with the highest carat,\nwith ties in carat broken by price (highest first).\n\n<details><summary><b>Solution</b> (click here)</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n  arrange(desc(carat), desc(price)) |>\n  slice_head(n = 3, by = color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.styled-output}\n# A tibble: 21 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  5.01 Fair      J     I1       65.5    59 18018 10.7  10.5   6.98\n 2  4.5  Fair      J     I1       65.8    58 18531 10.2  10.2   6.72\n 3  4.01 Premium   J     I1       62.5    62 15223 10.0   9.94  6.24\n 4  4.13 Fair      H     I1       64.8    61 17329 10     9.85  6.43\n 5  3.65 Fair      H     I1       67.1    53 11668  9.53  9.48  6.38\n 6  3.5  Ideal     H     I1       62.8    57 12587  9.65  9.59  6.03\n 7  4.01 Premium   I     I1       61      61 15223 10.1  10.1   6.17\n 8  4    Very Good I     I1       63.3    58 15984 10.0   9.94  6.31\n 9  3.67 Premium   I     I1       62.4    56 16193  9.86  9.81  6.13\n10  3.4  Fair      D     I1       66.8    52 15964  9.42  9.34  6.27\n# ℹ 11 more rows\n```\n\n\n:::\n:::\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}